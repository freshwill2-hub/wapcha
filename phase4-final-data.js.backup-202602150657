import dotenv from 'dotenv';
import axios from 'axios';
import FormData from 'form-data';
import fs from 'fs';
import { exec, execSync } from 'child_process';
import { promisify } from 'util';
import path from 'path';
import { GoogleGenerativeAI } from '@google/generative-ai';
// PlaywrightCrawler ì œê±° - searchNaverImagesê°€ axiosë¡œ ì „í™˜ë¨
import { trackGeminiCall, geminiCounter } from './gemini-api-counter.js';

dotenv.config();

const execAsync = promisify(exec);

// ==================== ë¡œê·¸ ì‹œìŠ¤í…œ ì„¤ì • ====================
const SYDNEY_TIMEZONE = 'Australia/Sydney';
const LOG_DIR = path.join(process.cwd(), 'logs');
const LOG_RETENTION_DAYS = 5;

if (!fs.existsSync(LOG_DIR)) {
    fs.mkdirSync(LOG_DIR, { recursive: true });
}

function getSydneyTime() {
    return new Date().toLocaleString('en-AU', { 
        timeZone: SYDNEY_TIMEZONE,
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        hour12: false
    });
}

function getSydneyTimeForFile() {
    const now = new Date();
    const sydneyDate = new Date(now.toLocaleString('en-US', { timeZone: SYDNEY_TIMEZONE }));
    const year = sydneyDate.getFullYear();
    const month = String(sydneyDate.getMonth() + 1).padStart(2, '0');
    const day = String(sydneyDate.getDate()).padStart(2, '0');
    const hour = String(sydneyDate.getHours()).padStart(2, '0');
    const min = String(sydneyDate.getMinutes()).padStart(2, '0');
    const sec = String(sydneyDate.getSeconds()).padStart(2, '0');
    return `${year}-${month}-${day}_${hour}-${min}-${sec}`;
}

function cleanupOldLogs() {
    const now = Date.now();
    const maxAge = LOG_RETENTION_DAYS * 24 * 60 * 60 * 1000;
    const deletedFiles = [];
    
    try {
        const files = fs.readdirSync(LOG_DIR);
        for (const file of files) {
            if (!file.endsWith('.log')) continue;
            const filePath = path.join(LOG_DIR, file);
            try {
                const stats = fs.statSync(filePath);
                if (now - stats.mtime.getTime() > maxAge) {
                    fs.unlinkSync(filePath);
                    deletedFiles.push(file);
                }
            } catch (error) {}
        }
    } catch (error) {}
    return deletedFiles;
}

const deletedLogs = cleanupOldLogs();

// âœ… í†µí•© ë¡œê·¸ ê²½ë¡œ (íŒŒì´í”„ë¼ì¸ ì‹¤í–‰ ì‹œ ì„¤ì •ë¨)
const UNIFIED_LOG_PATH = process.env.UNIFIED_LOG_PATH || null;

const LOG_FILENAME = `phase4_${getSydneyTimeForFile()}.log`;
const LOG_PATH = path.join(LOG_DIR, LOG_FILENAME);
const logStream = fs.createWriteStream(LOG_PATH, { flags: 'a' });

function log(...args) {
    const timestamp = `[${getSydneyTime()}]`;
    const message = args.join(' ');
    console.log(timestamp, message);
    logStream.write(`${timestamp} ${message}\n`);

    // âœ… í†µí•© ë¡œê·¸ì—ë„ ê¸°ë¡
    if (UNIFIED_LOG_PATH) {
        try {
            fs.appendFileSync(UNIFIED_LOG_PATH, `${timestamp} ${message}\n`);
        } catch (e) {
            // í†µí•© ë¡œê·¸ ê¸°ë¡ ì‹¤íŒ¨ ì‹œ ë¬´ì‹œ
        }
    }
}

// âœ… í†µí•© ë¡œê·¸ì— Phase ì‹œì‘ êµ¬ë¶„ì„  ì¶”ê°€
if (UNIFIED_LOG_PATH) {
    const separator = 'â•â•â• PHASE 4: ì´ë¯¸ì§€ ì„ ë³„ ì‹œì‘ â•â•â•';
    try {
        fs.appendFileSync(UNIFIED_LOG_PATH, `\n${separator}\n`);
    } catch (e) {
        // ë¬´ì‹œ
    }
}

// ==================== í™˜ê²½ ë³€ìˆ˜ ====================
const NOCODB_API_URL = process.env.NOCODB_API_URL;
const NOCODB_API_TOKEN = process.env.NOCODB_API_TOKEN;
const SHOPIFY_TABLE_ID = process.env.SHOPIFY_TABLE_ID;
const OLIVEYOUNG_TABLE_ID = process.env.OLIVEYOUNG_TABLE_ID;
const GOOGLE_GEMINI_API_KEY = process.env.GOOGLE_GEMINI_API_KEY;
const PYTHON_PATH = '/root/copychu-scraper/rembg-env/bin/python';
const REMBG_PATH = '/root/copychu-scraper/rembg-env/bin/rembg';

const genAI = new GoogleGenerativeAI(GOOGLE_GEMINI_API_KEY);

// ==================== ì„¤ì • ====================
const TARGET_SIZE = 1200;
const PRODUCT_RATIO = 0.75;
const MIN_SCORE_FOR_GALLERY = 60;  // âœ… v12: 50 â†’ 60ìœ¼ë¡œ ê°•í™”
const MIN_SCORE_FOR_MAIN = 35;     // âœ… v12: ë©”ì¸ ì´ë¯¸ì§€ ìµœì†Œ ì ìˆ˜ ì¶”ê°€

log('ğŸš€ Phase 4: ìµœê³  ì´ë¯¸ì§€ ì„ ë³„ + ë„¤ì´ë²„ ë³´ì¶© (v12 ë¨¸ì§€ ë²„ì „)');
log('='.repeat(70));
log(`âš™ï¸  ì„¤ì •:`);
log(`   - Shopify Table: ${SHOPIFY_TABLE_ID}`);
log(`   - ìµœì¢… í¬ê¸°: ${TARGET_SIZE}x${TARGET_SIZE}px`);
log(`   - ì œí’ˆ ë¹„ìœ¨: ${PRODUCT_RATIO * 100}%`);
log(`   - Gallery ìµœì†Œ ì ìˆ˜: ${MIN_SCORE_FOR_GALLERY}ì `);
log(`   - Main ìµœì†Œ ì ìˆ˜: ${MIN_SCORE_FOR_MAIN}ì `);
log(`\nâœ¨ v12 í•µì‹¬ ë³€ê²½ (v11 ìµœì í™” ìœ ì§€):`);
log(`   âœ… Gemini API í†µí•©: 6â†’2íšŒ (analyzeImageBasics + evaluateImageDetails)`);
log(`   âœ… Gallery ìµœì†Œ ì ìˆ˜: 50 â†’ 60`);
log(`   âœ… Main ìµœì†Œ ì ìˆ˜: 35 (ì‹ ê·œ)`);
log(`   âœ… ë¯¸í™•ì¸ í•­ëª© ë™ì •ì ìˆ˜: 5 â†’ 2`);
log(`   âœ… ê°œë³„ì œí’ˆ í¬ì¥ë°•ìŠ¤: -15 â†’ -30 (í•˜ë“œ ê°ì )`);
log(`   âœ… ì´ë¯¸ ì²˜ë¦¬ëœ ì œí’ˆ ì¬ì²˜ë¦¬ ë°©ì§€`);
log(`   âœ… ë„¤ì´ë²„ ì´ë¯¸ì§€ rembg í›„ 10KB ë¯¸ë§Œ ê±´ë„ˆë›°ê¸°`);
log(`   âœ… ìš©ëŸ‰ ë¶ˆì¼ì¹˜: í•˜ë“œíƒˆë½ â†’ -30 ê°ì \n`);

// ==================== ìœ í‹¸ë¦¬í‹° ====================
const cleanupFiles = (...files) => {
    files.forEach(file => {
        if (fs.existsSync(file)) {
            fs.unlinkSync(file);
        }
    });
};

// âœ… v14: ì´ë¯¸ì§€ ìœ ì‚¬ë„ í•´ì‹œ (8x8 í‰ê·  í•´ì‹œ)
function calculateImageHash(imagePath) {
    try {
        const pythonScript = `/tmp/imghash_${Date.now()}.py`;
        const script = `from PIL import Image
img = Image.open('${imagePath}').resize((8, 8)).convert('L')
pixels = list(img.getdata())
avg = sum(pixels) / 64
hash_val = ''.join(['1' if p > avg else '0' for p in pixels])
print(hash_val)
`;
        fs.writeFileSync(pythonScript, script);
        const result = execSync(`${PYTHON_PATH} ${pythonScript}`, { encoding: 'utf-8' }).trim();
        cleanupFiles(pythonScript);
        return result;
    } catch (error) {
        return null;
    }
}

function hammingDistance(hash1, hash2) {
    if (!hash1 || !hash2 || hash1.length !== hash2.length) return 64;
    let dist = 0;
    for (let i = 0; i < hash1.length; i++) {
        if (hash1[i] !== hash2[i]) dist++;
    }
    return dist;
}

function removeSimilarImages(scoredImages) {
    if (scoredImages.length <= 1) return scoredImages;

    log(`\n   ğŸ” ìœ ì‚¬ ì´ë¯¸ì§€ ê°ì§€ ì¤‘...`);
    const hashes = scoredImages.map(img => ({
        img,
        hash: img.imagePath ? calculateImageHash(img.imagePath) : null
    }));

    const kept = [];
    for (const item of hashes) {
        let isDuplicate = false;
        for (const existing of kept) {
            const dist = hammingDistance(item.hash, existing.hash);
            if (dist <= 10) {
                log(`   âš ï¸  ìœ ì‚¬ ì´ë¯¸ì§€ ì œê±°: í•´ë° ê±°ë¦¬ ${dist} (ì ìˆ˜ ${item.img.totalScore}ì  < ${existing.img.totalScore}ì )`);
                isDuplicate = true;
                break;
            }
        }
        if (!isDuplicate) {
            kept.push(item);
        }
    }

    log(`   âœ… ìœ ì‚¬ ì œê±° í›„: ${kept.length}ê°œ (ì›ë³¸ ${scoredImages.length}ê°œ)`);
    return kept.map(k => k.img);
}

// ==================== Oliveyoung ì œí’ˆ ì •ë³´ ê°€ì ¸ì˜¤ê¸° ====================
async function getOliveyoungProduct(productId) {
    try {
        const response = await axios.get(
            `${NOCODB_API_URL}/api/v2/tables/${OLIVEYOUNG_TABLE_ID}/records`,
            {
                headers: { 'xc-token': NOCODB_API_TOKEN },
                params: { where: `(Id,eq,${productId})` }
            }
        );
        
        if (response.data.list.length > 0) {
            return response.data.list[0];
        }
        return null;
    } catch (error) {
        log(`   âš ï¸  Oliveyoung ì œí’ˆ ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨:`, error.message);
        return null;
    }
}

// ==================== NocoDBì—ì„œ ì œí’ˆ ê°€ì ¸ì˜¤ê¸° ====================
async function getProductsFromNocoDB() {
    const response = await axios.get(
        `${NOCODB_API_URL}/api/v2/tables/${SHOPIFY_TABLE_ID}/records`,
        {
            headers: { 'xc-token': NOCODB_API_TOKEN },
            params: {
                limit: parseInt(process.env.PRODUCT_LIMIT) || 1000,
                // âœ… v12: ì´ë¯¸ ì²˜ë¦¬ëœ ì œí’ˆ ì¬ì²˜ë¦¬ ë°©ì§€
                where: '~and(validated_images,notnull)~and(main_image,is,null)'
            }
        }
    );

    // âœ… v11: NocoDB notnull í•„í„°ê°€ attachment í•„ë“œì—ì„œ ë¶ˆì•ˆì •í•˜ë¯€ë¡œ JSì—ì„œ í•„í„°ë§
    return response.data.list.filter(product =>
        product.validated_images &&
        Array.isArray(product.validated_images) &&
        product.validated_images.length > 0
    );
}

// ==================== ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œ ====================
async function downloadImage(imageUrl, outputPath) {
    const response = await axios.get(imageUrl, {
        responseType: 'arraybuffer',
        timeout: 30000,
        headers: {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
            'Referer': 'https://www.naver.com'
        }
    });
    fs.writeFileSync(outputPath, Buffer.from(response.data));
}

// ==================== ì´ë¯¸ì§€ í•´ìƒë„ í™•ì¸ ====================
function getImageResolution(imagePath) {
    try {
        const pythonScript = `
from PIL import Image
img = Image.open('${imagePath}')
print(f'{img.width},{img.height}')
`;
        
        const scriptPath = `/tmp/get_resolution_${Date.now()}.py`;
        fs.writeFileSync(scriptPath, pythonScript);
        
        const result = execSync(`${PYTHON_PATH} ${scriptPath}`, { encoding: 'utf-8' }).trim();
        cleanupFiles(scriptPath);
        
        const [width, height] = result.split(',').map(Number);
        
        if (!width || !height || isNaN(width) || isNaN(height)) {
            return null;
        }
        
        return { width, height, minDimension: Math.min(width, height) };
        
    } catch (error) {
        log('      âŒ í•´ìƒë„ í™•ì¸ ì˜¤ë¥˜:', error.message);
        return null;
    }
}

// ==================== ì œí’ˆëª…ì—ì„œ ì •ë³´ ì¶”ì¶œ ====================
function extractProductInfo(productTitle) {
    const info = {
        brandName: null,
        productLineName: null,
        volume: null,
        volumeNumber: null,
        volumeUnit: null,
        setCount: null,
        isSetProduct: false
    };
    
    // âœ… v11: ì˜ë¬¸ + í•œêµ­ì–´ + í™•ì¥ ë¼í‹´ ë¸Œëœë“œ ëª¨ë‘ ì¸ì‹
    const brandMatch = productTitle.match(/^([A-Za-z\u00C0-\u024F]+)/);
    if (brandMatch) {
        info.brandName = brandMatch[1].toLowerCase();
    } else {
        const koreanBrandMatch = productTitle.match(/^([ê°€-í£A-Za-z0-9]+)/);
        if (koreanBrandMatch) {
            info.brandName = koreanBrandMatch[1].toLowerCase();
        }
    }
    
    const productLineMatch = productTitle.match(/^[A-Za-z]+\s+(.+?)(?:\s+\d+\s*(?:ml|mL|g|G|pcs|ê°œ)|\s+Set|\s+ì„¸íŠ¸|$)/i);
    if (productLineMatch) {
        info.productLineName = productLineMatch[1].trim().toLowerCase();
    }
    
    const volumeMatch = productTitle.match(/(\d+)\s*(ml|mL|ML|g|G)/i);
    if (volumeMatch) {
        info.volumeNumber = parseInt(volumeMatch[1]);
        info.volumeUnit = volumeMatch[2].toLowerCase();
        info.volume = `${info.volumeNumber}${info.volumeUnit}`;
    }
    
    const setMatch = productTitle.match(/set of (\d+)|(\d+)ê°œ|(\d+)\s*pcs?|(\d+)\s*pack|(\d+)\s*bottles?|(\d+)\s*ea/i);
    if (setMatch) {
        info.setCount = parseInt(setMatch[1] || setMatch[2] || setMatch[3] || setMatch[4] || setMatch[5] || setMatch[6]);
        info.isSetProduct = info.setCount > 1;
    }

    if (!info.isSetProduct) {
        info.isSetProduct = /ì„¸íŠ¸|set|ë“€ì˜¤|duo|íŠ¸ìœˆ|twin|ë”ë¸”|double|íŠ¸ë¦¬í”Œ|triple|\d\+\d/i.test(productTitle);
    }
    
    return info;
}

// ==================== 1. í•´ìƒë„ ì ìˆ˜ (0-30ì ) ====================
function calculateResolutionScore(resolution) {
    if (!resolution) return 0;
    
    const { width, height } = resolution;
    const avgResolution = (width + height) / 2;
    
    if (avgResolution >= 1200) return 30;
    if (avgResolution >= 1000) return 25;
    if (avgResolution >= 800) return 20;
    if (avgResolution >= 600) return 15;
    return 10;
}

// ==================== í†µí•© API: ê¸°ë³¸ ë¶„ì„ (ì—¬ëŸ¬ì œí’ˆ + í¬ì¥ë°•ìŠ¤ + ì™„ì„±ë„) ====================
async function analyzeImageBasics(imagePath, productTitle, productInfo) {
    try {
        const isSetProduct = productInfo.isSetProduct;

        const imageBuffer = fs.readFileSync(imagePath);
        const base64 = imageBuffer.toString('base64');

        const model = genAI.getGenerativeModel({ model: 'gemini-2.0-flash' });

        const expectedCount = productInfo.setCount || 1;

        const prompt = `ì´ ì œí’ˆ ì´ë¯¸ì§€ë¥¼ ë¶„ì„í•´ì£¼ì„¸ìš”.

ì œí’ˆëª…: "${productTitle}"
ì˜ˆìƒ ì œí’ˆ ê°œìˆ˜: ${expectedCount}ê°œ

ë‹¤ìŒ 3ê°€ì§€ë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”:

1. **ì œí’ˆ ê°œìˆ˜**: ì´ ì´ë¯¸ì§€ì— ë™ì¼í•œ ì œí’ˆì´ ëª‡ ê°œ ë³´ì´ë‚˜ìš”?
   - ì‹¤ë¬¼ ì œí’ˆ(í™”ì¥í’ˆ ë³‘, íŠœë¸Œ, ìš©ê¸° ë“±)ë§Œ ì¹´ìš´íŠ¸
   - ê·¸ë¦¼ì, ë°˜ì‚¬, í¬ì¥ë°•ìŠ¤ëŠ” ì œì™¸

2. **í¬ì¥ë°•ìŠ¤**: ì œí’ˆ ë³¸ì²´ ì™¸ì— ì¢…ì´ ìƒì/íŒ¨í‚¤ì§€ ë°•ìŠ¤ê°€ ìˆë‚˜ìš”?
   - ì œí’ˆ ìš©ê¸°(ë³‘, íŠœë¸Œ, íŒí”„ë³‘) ì™¸ì— ì¢…ì´ ìƒì/ê³¨íŒì§€ ë°•ìŠ¤ê°€ ë³´ì´ëŠ”ê°€?
   - ì œí’ˆì´ ë°•ìŠ¤ ì•ˆì— ë“¤ì–´ìˆê±°ë‚˜ ë°•ìŠ¤ ì•ì— ë†“ì—¬ìˆëŠ” ê²½ìš°ë„ í¬í•¨
   - ë°•ìŠ¤ë§Œ ë³´ì´ê³  ì‹¤ì œ ì œí’ˆ ìš©ê¸°ê°€ ì•ˆ ë³´ì´ëŠ” ê²½ìš° ë°˜ë“œì‹œ HAS_PACKAGING: YES

3. **ì œí’ˆ ìš©ê¸° í™•ì¸**: ì‹¤ì œ ì œí’ˆ ìš©ê¸°(ë³‘, íŠœë¸Œ, íŒí”„ë³‘, ë“œë¡œí¼ ë“±)ê°€ ë³´ì´ë‚˜ìš”?
   - ì¢…ì´ ë°•ìŠ¤ë§Œ ë³´ì´ê³  ì‹¤ì œ ì œí’ˆ ìš©ê¸°ê°€ ì•ˆ ë³´ì´ë©´ PRODUCT_VISIBLE: NO

4. **ì™„ì„±ë„**: ì œí’ˆì´ ì™„ì „í•œê°€ìš”?
   - ì œí’ˆì´ ì˜ë ¤ìˆë‚˜ìš”? (ìº¡, ë°”ë””, í•˜ë‹¨)
   - ì œí’ˆ ì „ì²´ê°€ ì´ë¯¸ì§€ ì•ˆì— ìˆë‚˜ìš”?

ë‹¤ìŒ í˜•ì‹ìœ¼ë¡œë§Œ ë‹µë³€í•˜ì„¸ìš”:
PRODUCT_COUNT: [ìˆ«ì]
HAS_PACKAGING: [YES/NO]
PRODUCT_VISIBLE: [YES/NO]
IS_COMPLETE: [YES/NO]`;

        const result = await model.generateContent([
            prompt,
            {
                inlineData: {
                    data: base64,
                    mimeType: 'image/png'
                }
            }
        ]);

        trackGeminiCall('analyzeImageBasics');

        const response = result.response.text().trim();

        const countMatch = response.match(/PRODUCT_COUNT:\s*(\d+)/i);
        const packagingMatch = response.match(/HAS_PACKAGING:\s*(YES|NO)/i);
        const productVisibleMatch = response.match(/PRODUCT_VISIBLE:\s*(YES|NO)/i);
        const completeMatch = response.match(/IS_COMPLETE:\s*(YES|NO)/i);

        const detectedCount = countMatch ? parseInt(countMatch[1]) : 1;
        const hasPackaging = packagingMatch ? packagingMatch[1].toUpperCase() === 'YES' : false;
        const productVisible = productVisibleMatch ? productVisibleMatch[1].toUpperCase() === 'YES' : true;
        const isComplete = completeMatch ? completeMatch[1].toUpperCase() === 'YES' : false;

        // ì—¬ëŸ¬ ì œí’ˆ ê°ì  (ì„¸íŠ¸ ì œí’ˆì´ë©´ ìŠ¤í‚µ)
        let multipleProductsPenalty = 0;
        if (isSetProduct) {
            log(`      ğŸ ì„¸íŠ¸ ì œí’ˆ â†’ ì—¬ëŸ¬ ì œí’ˆ ê²€ì‚¬ ìƒëµ`);
        } else {
            if (detectedCount >= 2) {
                multipleProductsPenalty = -40;
                log(`      âš ï¸  ì—¬ëŸ¬ ì œí’ˆ ê°ì§€ (${detectedCount}ê°œ)`);
                log(`      ğŸ“‰ ê°ì : -40ì  (ê°œë³„ ì œí’ˆì— ë‹¤ë¥¸ ì œí’ˆ í¬í•¨!)`);
            } else {
                log(`      âœ… ë‹¨ì¼ ì œí’ˆ í™•ì¸ (${detectedCount}ê°œ)`);
            }
        }

        // âœ… v15: í¬ì¥ë°•ìŠ¤ ê°ì  - ê°œë³„/ì„¸íŠ¸ ëª¨ë‘ -30 (í•˜ë“œíƒˆë½ì€ productNotVisibleì¼ ë•Œë§Œ)
        let packagingPenalty = 0;
        if (hasPackaging) {
            packagingPenalty = -30;
            log(`      âš ï¸  í¬ì¥ë°•ìŠ¤ ê°ì§€ë¨`);
            log(`      ğŸ“‰ ê°ì : -30ì  (íƒˆë½ ì•„ë‹˜!)`);
        } else {
            log(`      âœ… í¬ì¥ë°•ìŠ¤ ì—†ìŒ`);
        }

        // ì™„ì„±ë„ ì ìˆ˜
        let completenessScore;
        if (isComplete) {
            completenessScore = 25;
            log(`      âœ… ì™„ì„±ë„: 25/25ì `);
        } else {
            completenessScore = 10;
            log(`      âš ï¸  ì™„ì„±ë„: 10/25ì `);
            log(`      ğŸ“‰ ë¶ˆì™„ì „í•˜ì§€ë§Œ ê³„ì† í‰ê°€! (íƒˆë½ ì•„ë‹˜)`);
        }

        return {
            multipleProductsPenalty,
            packagingPenalty,
            completenessScore,
            productNotVisible: !productVisible
        };

    } catch (error) {
        log('      âŒ ê¸°ë³¸ ë¶„ì„ ì‹¤íŒ¨:', error.message);
        return {
            multipleProductsPenalty: 0,
            packagingPenalty: 0,
            completenessScore: 15,
            productNotVisible: false
        };
    }
}

// ==================== í†µí•© API: ìƒì„¸ í‰ê°€ (íƒ€ì´í‹€ë§¤ì¹­ + ì„¸íŠ¸êµ¬ì„± + í’ˆì§ˆ) ====================
async function evaluateImageDetails(imagePath, productTitle, productInfo, originalImageUrl = null) {
    try {
        let base64;
        let imageSource = 'í¬ë¡­ ì´ë¯¸ì§€';

        if (originalImageUrl) {
            try {
                log(`      ğŸ“¥ ì›ë³¸ ì´ë¯¸ì§€ë¡œ í™•ì¸ ì¤‘...`);
                const response = await axios.get(originalImageUrl, {
                    responseType: 'arraybuffer',
                    timeout: 30000,
                    headers: {
                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
                        'Referer': 'https://www.oliveyoung.co.kr'
                    }
                });
                base64 = Buffer.from(response.data).toString('base64');
                imageSource = 'ì›ë³¸ ì´ë¯¸ì§€';
                log(`      âœ… ì›ë³¸ ì´ë¯¸ì§€ ë¡œë“œ ì™„ë£Œ`);
            } catch (err) {
                log(`      âš ï¸  ì›ë³¸ ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨, í¬ë¡­ ì´ë¯¸ì§€ ì‚¬ìš©`);
                const imageBuffer = fs.readFileSync(imagePath);
                base64 = imageBuffer.toString('base64');
            }
        } else {
            const imageBuffer = fs.readFileSync(imagePath);
            base64 = imageBuffer.toString('base64');
        }

        log(`      ğŸ–¼ï¸  ê²€ì‚¬ ëŒ€ìƒ: ${imageSource}`);

        const model = genAI.getGenerativeModel({ model: 'gemini-2.0-flash' });

        const isSetProduct = productInfo.setCount && productInfo.setCount > 1;
        const setSection = isSetProduct ? `
5. **ì„¸íŠ¸ êµ¬ì„±**: ì˜ˆìƒ ì„¸íŠ¸ ê°œìˆ˜ ${productInfo.setCount}ê°œ ëŒ€ë¹„ ì‹¤ì œ ê°œìˆ˜ì™€ ì í•©ë„
   - COUNT: [ìˆ«ì]
   - SET_SUITABLE: [EXCELLENT/GOOD/FAIR/POOR]` : '';

        const setFormat = isSetProduct ? `
SET_COUNT: [ìˆ«ì]
SET_SUITABLE: [EXCELLENT/GOOD/FAIR/POOR]` : '';

        const prompt = `ì´ ì œí’ˆ ì´ë¯¸ì§€ë¥¼ ë¶„ì„í•´ì£¼ì„¸ìš”.

**íƒ€ê²Ÿ ì œí’ˆ:**
- ë¸Œëœë“œ: "${productInfo.brandName || 'N/A'}"
- ì œí’ˆ ë¼ì¸: "${productInfo.productLineName || 'N/A'}"
- ìš©ëŸ‰: "${productInfo.volume || 'N/A'}"

**ì´ë¯¸ì§€ì—ì„œ ë‹¤ìŒì„ í™•ì¸í•´ì£¼ì„¸ìš”:**
1. **ë¸Œëœë“œëª…**: ì´ë¯¸ì§€ì—ì„œ ì½ì€ ë¸Œëœë“œ
2. **ì œí’ˆëª…/ë¼ì¸ëª…**: ì´ë¯¸ì§€ì—ì„œ ì½ì€ ì œí’ˆ ë¼ì¸
3. **ìš©ëŸ‰**: ml, g ë“±
4. **ì´ë¯¸ì§€ í’ˆì§ˆ**: ì„ ëª…ë„, ì¤‘ì•™ ë°°ì¹˜, ë°°ê²½ í’ˆì§ˆ, ì‡¼í•‘ëª° ì‚¬ìš© ì í•©ì„± (0-20ì )
5. **ì‚¬ì€í’ˆ/ì¦ì •í’ˆ**: ë©”ì¸ ì œí’ˆ ì™¸ì— ë¯¸ë‹ˆì–´ì²˜, íŒŒìš°ì¹˜, ë´‰ì œì¸í˜•, ë¦¬í•„íŒ©, ë§ˆìŠ¤í¬íŒ©, ì‹œíŠ¸ë§ˆìŠ¤í¬, ìº˜ë¦°ë”, ì¸í˜•, í‚¤ë§ ë“± ì‚¬ì€í’ˆì´ ë³´ì´ëŠ”ê°€?
6. **ìœ ë ¹ ì”ìƒ**: ë°°ê²½ì— ë°˜íˆ¬ëª… ìœ ë ¹ ì”ìƒ(ghost artifact)ì´ ë³´ì´ëŠ”ê°€? (ë‹¤ë¥¸ ì œí’ˆì˜ ì‹¤ë£¨ì—£, íë¦¿í•œ ë„í˜•, ë°˜íˆ¬ëª… í…ìŠ¤íŠ¸ ë“±)${setSection}

ë‹¤ìŒ í˜•ì‹ìœ¼ë¡œë§Œ ë‹µë³€:
BRAND: [ì½ì€ ë¸Œëœë“œëª… ë˜ëŠ” UNKNOWN]
PRODUCT_LINE: [ì½ì€ ì œí’ˆë¼ì¸ëª… ë˜ëŠ” UNKNOWN]
VOLUME: [ì½ì€ ìš©ëŸ‰ ë˜ëŠ” UNKNOWN]
QUALITY: [0-20 ìˆ«ì]
HAS_GIFT_ITEMS: [YES/NO]
HAS_GHOST_ARTIFACT: [YES/NO]${setFormat}`;

        const result = await model.generateContent([
            prompt,
            {
                inlineData: {
                    data: base64,
                    mimeType: 'image/png'
                }
            }
        ]);

        trackGeminiCall('evaluateImageDetails');

        const response = result.response.text().trim();
        log(`      ğŸ“„ Gemini ì‘ë‹µ:\n${response.split('\n').map(l => '         ' + l).join('\n')}`);

        // === íƒ€ì´í‹€ ë§¤ì¹­ ì ìˆ˜ ê³„ì‚° ===
        const brandMatch = response.match(/BRAND:\s*([^\n]+)/i);
        const productLineMatch = response.match(/PRODUCT_LINE:\s*([^\n]+)/i);
        const volumeMatch = response.match(/VOLUME:\s*([^\n]+)/i);

        const detectedBrand = brandMatch ? brandMatch[1].trim().toLowerCase() : 'unknown';
        const detectedProductLine = productLineMatch ? productLineMatch[1].trim().toLowerCase() : 'unknown';
        const detectedVolume = volumeMatch ? volumeMatch[1].trim().toLowerCase() : 'unknown';

        let titleMatchScore = 0;
        const targetBrand = (productInfo.brandName || '').toLowerCase();
        const targetLine = (productInfo.productLineName || '').toLowerCase();

        // âœ… v13: ë¸Œëœë“œ í™•ì¸ (ë¶ˆì¼ì¹˜ 0ì , ë¯¸í™•ì¸ 1ì )
        let brandClearlyDifferent = false;
        if (detectedBrand !== 'unknown' && targetBrand) {
            if (detectedBrand.includes(targetBrand) || targetBrand.includes(detectedBrand)) {
                titleMatchScore += 10;
                log(`      âœ… ë¸Œëœë“œ ì¼ì¹˜: ${detectedBrand} (+10ì )`);
            } else {
                titleMatchScore += 0;  // âœ… v13: 2 â†’ 0 (ë™ì •ì ìˆ˜ ì œê±°)
                log(`      âš ï¸  ë¸Œëœë“œ ë¶ˆì¼ì¹˜: ${detectedBrand} â‰  ${targetBrand} (+0ì )`);
                // ë¸Œëœë“œê°€ 3ê¸€ì ì´ìƒì´ê³  ì„œë¡œ ì™„ì „íˆ ë‹¤ë¥´ë©´ í•˜ë“œ íƒˆë½ ëŒ€ìƒ
                if (detectedBrand.length >= 3 && targetBrand.length >= 3) {
                    brandClearlyDifferent = true;
                    log(`      ğŸš« ë¸Œëœë“œ ëª…í™•íˆ ë‹¤ë¦„: "${detectedBrand}" â‰  "${targetBrand}"`);
                }
            }
        } else {
            titleMatchScore += 1;  // âœ… v13: 2 â†’ 1
            log(`      âš ï¸  ë¸Œëœë“œ ë¯¸í™•ì¸ (+1ì )`);
        }

        // âœ… v13: ì œí’ˆ ë¼ì¸ í™•ì¸ (ë¶ˆì¼ì¹˜ 1ì , ë¯¸í™•ì¸ 1ì )
        if (detectedProductLine !== 'unknown' && targetLine) {
            const targetWords = targetLine.split(' ').slice(0, 2).join(' ');
            const detectedWords = detectedProductLine.split(' ').slice(0, 2).join(' ');

            if (detectedProductLine.includes(targetWords) || targetLine.includes(detectedWords) ||
                detectedWords.includes(targetWords) || targetWords.includes(detectedWords)) {
                titleMatchScore += 10;
                log(`      âœ… ì œí’ˆ ë¼ì¸ ì¼ì¹˜ (+10ì )`);
            } else {
                titleMatchScore += 1;  // âœ… v13: 2 â†’ 1
                log(`      âš ï¸  ì œí’ˆ ë¼ì¸ ë¶ˆì¼ì¹˜ (+1ì )`);
            }
        } else {
            titleMatchScore += 1;  // âœ… v13: 2 â†’ 1
            log(`      âš ï¸  ì œí’ˆ ë¼ì¸ ë¯¸í™•ì¸ (+1ì )`);
        }

        // âœ… v12: ìš©ëŸ‰ í™•ì¸ (í•˜ë“œíƒˆë½ â†’ -30 ê°ì )
        let volumePenalty = 0;
        if (detectedVolume !== 'unknown' && productInfo.volume) {
            const detectedNum = parseInt(detectedVolume.match(/\d+/)?.[0] || '0');
            const expectedNum = productInfo.volumeNumber;

            if (expectedNum && detectedNum > 0) {
                const diffPercent = Math.abs(detectedNum - expectedNum) / expectedNum * 100;

                if (detectedNum === expectedNum) {
                    titleMatchScore += 10;
                    log(`      âœ… ìš©ëŸ‰ ì¼ì¹˜: ${detectedVolume} (+10ì )`);
                } else if (diffPercent <= 15) {
                    titleMatchScore += 7;
                    log(`      âš ï¸  ìš©ëŸ‰ ê·¼ì‚¬: ${detectedVolume} â‰ˆ ${productInfo.volume} (+7ì )`);
                } else if (diffPercent <= 30) {
                    titleMatchScore += 3;
                    log(`      âš ï¸  ìš©ëŸ‰ ì°¨ì´: ${detectedVolume} â‰  ${productInfo.volume} (+3ì )`);
                } else {
                    // âœ… v12: í•˜ë“œíƒˆë½ ëŒ€ì‹  -30 ê°ì 
                    volumePenalty = -30;
                    log(`      âŒ ìš©ëŸ‰ í¬ê²Œ ë¶ˆì¼ì¹˜: ${detectedVolume} â‰  ${productInfo.volume}`);
                    log(`      ğŸ“‰ ë‹¤ë¥¸ ì œí’ˆ ê°ì : -30ì `);
                }
            }
        } else {
            titleMatchScore += 1;  // âœ… v13: 2 â†’ 1
            log(`      âš ï¸  ìš©ëŸ‰ ë¯¸í™•ì¸ (+1ì )`);
        }

        titleMatchScore += volumePenalty;
        log(`      ğŸ“Š íƒ€ì´í‹€ ë§¤ì¹­: ${titleMatchScore}/30ì `);

        // === ì„¸íŠ¸ êµ¬ì„± ì ìˆ˜ ê³„ì‚° ===
        let setCompositionScore;
        if (!isSetProduct) {
            setCompositionScore = 20;
            log(`      âœ… ë‹¨ì¼ ì œí’ˆ â†’ ìë™ 20ì `);
        } else {
            log(`      ğŸ ì„¸íŠ¸ ì œí’ˆ: ${productInfo.setCount}ê°œ ì˜ˆìƒ`);

            const setCountMatch = response.match(/SET_COUNT:\s*(\d+)/i);
            const suitableMatch = response.match(/SET_SUITABLE:\s*(EXCELLENT|GOOD|FAIR|POOR)/i);

            const detectedCount = setCountMatch ? parseInt(setCountMatch[1]) : 0;
            const suitable = suitableMatch ? suitableMatch[1].toUpperCase() : 'FAIR';

            setCompositionScore = 0;

            if (detectedCount === productInfo.setCount) {
                setCompositionScore += 10;
            } else if (Math.abs(detectedCount - productInfo.setCount) === 1) {
                setCompositionScore += 5;
            }

            if (suitable === 'EXCELLENT') setCompositionScore += 10;
            else if (suitable === 'GOOD') setCompositionScore += 7;
            else if (suitable === 'FAIR') setCompositionScore += 4;
            else setCompositionScore += 2;

            setCompositionScore = Math.max(0, Math.min(20, setCompositionScore));
            log(`      ğŸ“Š ì„¸íŠ¸ êµ¬ì„±: ${setCompositionScore}/20ì `);
        }

        // === í’ˆì§ˆ ì ìˆ˜ ê³„ì‚° ===
        const qualityMatch = response.match(/QUALITY:\s*(\d+)/i);
        let qualityScore = qualityMatch ? parseInt(qualityMatch[1]) : 12;

        if (isNaN(qualityScore) || qualityScore < 0 || qualityScore > 20) {
            log(`      âš ï¸  ìœ íš¨í•˜ì§€ ì•Šì€ í’ˆì§ˆ ì ìˆ˜: ${qualityScore}, ê¸°ë³¸ê°’ 12ì  ì‚¬ìš©`);
            qualityScore = 12;
        }

        log(`      ğŸ“Š ì´ë¯¸ì§€ í’ˆì§ˆ: ${qualityScore}/20ì `);

        // âœ… v13: ì‚¬ì€í’ˆ/ì¦ì •í’ˆ ê°ì§€ (FIX-2B)
        const giftMatch = response.match(/HAS_GIFT_ITEMS:\s*(YES|NO)/i);
        const hasGiftItems = giftMatch ? giftMatch[1].toUpperCase() === 'YES' : false;
        let giftPenalty = 0;
        if (hasGiftItems && !productInfo.isSetProduct) {
            giftPenalty = -25;
            log(`      âš ï¸  ì‚¬ì€í’ˆ/ì¦ì •í’ˆ ê°ì§€ë¨ â†’ ê°ì : -25ì `);
        }

        // âœ… v13: ìœ ë ¹ ì”ìƒ ê°ì§€ (FIX-3B)
        const ghostMatch = response.match(/HAS_GHOST_ARTIFACT:\s*(YES|NO)/i);
        const hasGhostArtifact = ghostMatch ? ghostMatch[1].toUpperCase() === 'YES' : false;
        let ghostPenalty = 0;
        if (hasGhostArtifact) {
            ghostPenalty = -15;
            log(`      âš ï¸  ìœ ë ¹ ì”ìƒ(ghost artifact) ê°ì§€ë¨ â†’ ê°ì : -15ì `);
        }

        return {
            titleMatchScore: { score: titleMatchScore, isWrongProduct: false },
            setCompositionScore,
            qualityScore,
            brandClearlyDifferent,
            giftPenalty,
            ghostPenalty,
            hasGiftItems,
            hasGhostArtifact
        };

    } catch (error) {
        log('      âŒ ìƒì„¸ í‰ê°€ ì‹¤íŒ¨:', error.message);
        return {
            titleMatchScore: { score: 10, isWrongProduct: false },  // âœ… v15: 15 â†’ 10 (ì—ëŸ¬ ì‹œ ë™ì •ì ìˆ˜ í•˜í–¥)
            setCompositionScore: 10,
            qualityScore: 12
        };
    }
}

// ==================== v12 ë¨¸ì§€: ì´ë¯¸ì§€ ì ìˆ˜ ê³„ì‚° (í†µí•© API ì‚¬ìš©) ====================
async function scoreImage(imageData, imagePath, productTitle, productInfo, index) {
    log(`\n   ì´ë¯¸ì§€ ${index + 1} í‰ê°€:`);
    log(`   ${'â”€'.repeat(66)}`);
    
    const scores = {
        resolution: 0,
        completeness: 0,
        titleMatch: 0,
        setComposition: 0,
        quality: 0,
        penalties: 0
    };
    
    const resolution = getImageResolution(imagePath);
    scores.resolution = calculateResolutionScore(resolution);
    log(`      ğŸ“ í•´ìƒë„: ${scores.resolution}/30ì  (${resolution?.width}x${resolution?.height})`);
    
    // âœ… í†µí•© API 1: ê¸°ë³¸ ë¶„ì„ (ì—¬ëŸ¬ì œí’ˆ + í¬ì¥ë°•ìŠ¤ + ì™„ì„±ë„) - API 1íšŒ
    const basics = await analyzeImageBasics(imagePath, productTitle, productInfo);
    scores.penalties += basics.multipleProductsPenalty;
    scores.penalties += basics.packagingPenalty;
    scores.completeness = basics.completenessScore;

    // âœ… í†µí•© API 2: ìƒì„¸ í‰ê°€ (íƒ€ì´í‹€ë§¤ì¹­ + ì„¸íŠ¸êµ¬ì„± + í’ˆì§ˆ) - API 1íšŒ
    const details = await evaluateImageDetails(imagePath, productTitle, productInfo, imageData.originalUrl || null);
    scores.titleMatch = details.titleMatchScore.score;
    scores.setComposition = details.setCompositionScore;
    scores.quality = details.qualityScore;

    // âœ… v13: ì‚¬ì€í’ˆ/ìœ ë ¹ì”ìƒ ê°ì  ì ìš©
    if (details.giftPenalty) {
        scores.penalties += details.giftPenalty;
    }
    if (details.ghostPenalty) {
        scores.penalties += details.ghostPenalty;
    }

    // âœ… v10: í’ˆì§ˆì´ ë„ˆë¬´ ë‚®ìœ¼ë©´ ê°ì !
    if (scores.quality < 12) {
        scores.penalties += -20;
        log(`      ğŸ“‰ í’ˆì§ˆ ì €í•˜ ê°ì : -20ì  (í’ˆì§ˆ ${scores.quality}ì  < 12ì )`);
    }
    
    // âœ… ì´ì  ê³„ì‚° (ê°ì  í¬í•¨)
    let totalScore = Math.max(0,
        scores.resolution + scores.completeness + scores.titleMatch +
        scores.setComposition + scores.quality + scores.penalties
    );

    // í•˜ë“œ íƒˆë½: ê°œë³„ ì œí’ˆì¸ë° ì—¬ëŸ¬ ì œí’ˆ ê°ì§€ â†’ ì´ì  0ì 
    if (!productInfo.isSetProduct && basics.multipleProductsPenalty < 0) {
        log(`      ğŸš« í•˜ë“œ íƒˆë½: ê°œë³„ ì œí’ˆì¸ë° ì—¬ëŸ¬ ì œí’ˆ ê°ì§€ â†’ 0ì `);
        totalScore = 0;
    }

    // í•˜ë“œ íƒˆë½: ìš©ëŸ‰ í¬ê²Œ ë¶ˆì¼ì¹˜ (titleMatchê°€ ìŒìˆ˜) â†’ ì´ì  0ì 
    if (scores.titleMatch < 0) {
        log(`      ğŸš« í•˜ë“œ íƒˆë½: ìš©ëŸ‰ í¬ê²Œ ë¶ˆì¼ì¹˜ â†’ 0ì `);
        totalScore = 0;
    }

    // âœ… v14: í¬ì¥ë°•ìŠ¤ í•˜ë“œ íƒˆë½ ì¡°ê±´ ì™„í™” - ì œí’ˆ ìš©ê¸° ì•ˆ ë³´ì¼ ë•Œë§Œ í•˜ë“œ íƒˆë½
    if (basics.packagingPenalty < 0 && basics.productNotVisible) {
        log(`      ğŸš« í•˜ë“œ íƒˆë½: ì œí’ˆ ìš©ê¸° ì•ˆ ë³´ì´ê³  íŒ¨í‚¤ì§•ë§Œ ìˆìŒ â†’ 0ì `);
        totalScore = 0;
    }

    // âœ… v13: í•˜ë“œ íƒˆë½: ë¸Œëœë“œê°€ ëª…í™•íˆ ë‹¤ë¦„ â†’ ì´ì  0ì  (FIX-4B)
    if (details.brandClearlyDifferent) {
        log(`      ğŸš« í•˜ë“œ íƒˆë½: ë¸Œëœë“œ ëª…í™•íˆ ë‹¤ë¦„ â†’ 0ì `);
        totalScore = 0;
    }

    log(`      ğŸ“‰ ê°ì : ${scores.penalties}ì `);
    log(`      ğŸ¯ ì´ì : ${totalScore}/125ì `);

    return {
        imageData,
        imagePath,
        resolution,
        scores,
        totalScore,
        isIncomplete: scores.completeness <= 10,
        isWrongProduct: scores.titleMatch < 0,
        hasPackaging: basics.packagingPenalty < 0,
        hasMultipleProducts: basics.multipleProductsPenalty < 0
    };
}

// ==================== í¬ê¸° ì •ê·œí™” ====================
function normalizeImage(imagePath) {
    log('      ğŸ“ í¬ê¸° ì •ê·œí™” ì¤‘...');
    const outputPath = imagePath.replace('.png', '_normalized.png');
    
    const pythonScript = `
from PIL import Image
import numpy as np

img = Image.open('${imagePath}')

if img.mode == 'RGBA':
    alpha = np.array(img.split()[3])
    rows = np.any(alpha > 10, axis=1)
    cols = np.any(alpha > 10, axis=0)
    
    if np.any(rows) and np.any(cols):
        y_min, y_max = np.where(rows)[0][[0, -1]]
        x_min, x_max = np.where(cols)[0][[0, -1]]
        product = img.crop((x_min, y_min, x_max + 1, y_max + 1))
    else:
        product = img
else:
    img_array = np.array(img)
    non_white = np.any(img_array < 250, axis=2)
    rows = np.any(non_white, axis=1)
    cols = np.any(non_white, axis=0)
    
    if np.any(rows) and np.any(cols):
        y_min, y_max = np.where(rows)[0][[0, -1]]
        x_min, x_max = np.where(cols)[0][[0, -1]]
        product = img.crop((x_min, y_min, x_max + 1, y_max + 1))
    else:
        product = img

target_size = ${TARGET_SIZE}
product_ratio = ${PRODUCT_RATIO}
target_product_size = int(target_size * product_ratio)

product_width, product_height = product.size
scale = min(target_product_size / product_width, target_product_size / product_height)

new_width = int(product_width * scale)
new_height = int(product_height * scale)

product_resized = product.resize((new_width, new_height), Image.Resampling.LANCZOS)

canvas = Image.new('RGB', (target_size, target_size), (255, 255, 255))

x_offset = (target_size - new_width) // 2
y_offset = (target_size - new_height) // 2

if product_resized.mode == 'RGBA':
    canvas.paste(product_resized, (x_offset, y_offset), product_resized.split()[3])
else:
    canvas.paste(product_resized, (x_offset, y_offset))

canvas.save('${outputPath}', 'PNG', quality=95)
`;
    
    const scriptPath = `/tmp/normalize_${Date.now()}.py`;
    fs.writeFileSync(scriptPath, pythonScript);
    
    try {
        execSync(`${PYTHON_PATH} ${scriptPath}`);
        log(`      âœ… ì •ê·œí™” ì™„ë£Œ: ${TARGET_SIZE}x${TARGET_SIZE}px`);
        cleanupFiles(scriptPath);
        return outputPath;
    } catch (error) {
        log('      âŒ ì •ê·œí™” ì‹¤íŒ¨:', error.message);
        cleanupFiles(scriptPath);
        return null;
    }
}

// ==================== NocoDB ì—…ë¡œë“œ ====================
async function uploadToNocoDB(filePath, fileName) {
    try {
        const formData = new FormData();
        formData.append('file', fs.createReadStream(filePath), fileName);
        
        const response = await axios.post(
            `${NOCODB_API_URL}/api/v2/storage/upload`,
            formData,
            {
                headers: {
                    'xc-token': NOCODB_API_TOKEN,
                    ...formData.getHeaders()
                },
                maxContentLength: Infinity,
                maxBodyLength: Infinity
            }
        );
        
        return response.data;
    } catch (error) {
        log('      âŒ ì—…ë¡œë“œ ì‹¤íŒ¨:', error.message);
        throw error;
    }
}

// ==================== ë„¤ì´ë²„ ì´ë¯¸ì§€ ê¸°ë³¸ ê²€ì¦ ====================
async function quickNaverImageCheck(imagePath, productInfo) {
    try {
        const imageBuffer = fs.readFileSync(imagePath);
        const base64 = imageBuffer.toString('base64');
        const model = genAI.getGenerativeModel({ model: 'gemini-2.0-flash' });

        const prompt = `ì´ ì œí’ˆ ì´ë¯¸ì§€ë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”.
íƒ€ê²Ÿ ë¸Œëœë“œ: "${productInfo.brandName || 'N/A'}"
íƒ€ê²Ÿ ìš©ëŸ‰: "${productInfo.volume || 'N/A'}"

ë‹¤ìŒì„ í™•ì¸í•´ì£¼ì„¸ìš”:
1. ì´ë¯¸ì§€ì˜ ì œí’ˆì´ íƒ€ê²Ÿê³¼ ê°™ì€ ë¸Œëœë“œ/ì œí’ˆì¸ê°€ìš”?
2. í”„ë¡œëª¨ì…˜ ë±ƒì§€/ë°°ë„ˆ/í…ìŠ¤íŠ¸ ì˜¤ë²„ë ˆì´ê°€ ìˆëŠ”ê°€?
3. ì‚¬ì€í’ˆ/ì¦ì •í’ˆì´ í•¨ê»˜ ë³´ì´ëŠ”ê°€?
4. ì‚¬ëŒ/ëª¨ë¸ ì‚¬ì§„ì¸ê°€?

MATCH: [YES/NO]
HAS_PROMO: [YES/NO]
HAS_GIFT: [YES/NO]
HAS_MODEL: [YES/NO]
REASON: [í•œ ì¤„]`;

        const result = await model.generateContent([
            prompt,
            { inlineData: { data: base64, mimeType: 'image/png' } }
        ]);

        trackGeminiCall('quickNaverImageCheck');

        const response = result.response.text().trim();
        const matchResult = response.match(/MATCH:\s*(YES|NO)/i);
        const promoResult = response.match(/HAS_PROMO:\s*(YES|NO)/i);
        const giftResult = response.match(/HAS_GIFT:\s*(YES|NO)/i);
        const modelResult = response.match(/HAS_MODEL:\s*(YES|NO)/i);
        const reasonMatch = response.match(/REASON:\s*([^\n]+)/i);

        let isMatch = matchResult ? matchResult[1].toUpperCase() === 'YES' : null;
        const hasPromo = promoResult ? promoResult[1].toUpperCase() === 'YES' : false;
        const hasGift = giftResult ? giftResult[1].toUpperCase() === 'YES' : false;
        const hasModel = modelResult ? modelResult[1].toUpperCase() === 'YES' : false;
        const reason = reasonMatch ? reasonMatch[1].trim() : response.substring(0, 150);

        // âœ… fallback: Geminiê°€ MATCH: YES/NO í˜•ì‹ìœ¼ë¡œ ë‹µí•˜ì§€ ì•Šì€ ê²½ìš°
        if (isMatch === null) {
            const upper = response.toUpperCase();
            // í”„ë¡¬í”„íŠ¸ ê±°ì ˆ ì¡°ê±´ì— ë§¤í•‘ëœ í‚¤ì›Œë“œ (í”„ë¡œëª¨ì…˜/ì¦ì •í’ˆ/ëª¨ë¸)
            const rejectSignals = [
                'PROMOTION', 'PROMO', 'GIFT', 'MODEL', 'PERSON', 'PEOPLE',
                'TEXT OVERLAY', 'BANNER', 'BADGE',
                'DOES NOT MATCH', 'NOT MATCH', 'MISMATCH', 'DIFFERENT BRAND',
                'í”„ë¡œëª¨ì…˜', 'ì¦ì •', 'ì‚¬ì€í’ˆ', 'ëª¨ë¸', 'ì‚¬ëŒ', 'ë°°ë„ˆ', 'ë¶ˆì¼ì¹˜', 'ë‹¤ë¥¸ ë¸Œëœë“œ', 'ë‹¤ë¥¸ ì œí’ˆ'
            ];
            // í”„ë¡¬í”„íŠ¸ í†µê³¼ ì¡°ê±´: ë¸Œëœë“œ/ì œí’ˆ ì¼ì¹˜, ë¬¸ì œ ì—†ìŒ
            const passSignals = [
                'NO VISIBLE PROMOTION', 'NO PROMOTION', 'NO PROMO',
                'NO GIFT', 'NO MODEL', 'NO PERSON', 'NO PEOPLE',
                'CLEAN', 'MATCHES', 'CORRECT BRAND',
                'í”„ë¡œëª¨ì…˜ ì—†', 'ì¦ì •í’ˆ ì—†', 'ëª¨ë¸ ì—†', 'ì‚¬ëŒ ì—†', 'ë°°ë„ˆ ì—†',
                'ì¼ì¹˜', 'ë§¤ì¹˜', 'ì í•©', 'ê¹¨ë—'
            ];

            const hasRejectSignal = rejectSignals.some(kw => upper.includes(kw));
            const hasPassSignal = passSignals.some(kw => upper.includes(kw));

            // í†µê³¼ ì‹ í˜¸ê°€ ìˆê³  ê±°ì ˆ ì‹ í˜¸ê°€ ì—†ìœ¼ë©´ â†’ í†µê³¼
            // "no promotion" ê°™ì€ ë¶€ì • í‘œí˜„ì€ passSignalsì—ì„œ ì²˜ë¦¬í•˜ë¯€ë¡œ
            // rejectSignalsì˜ "PROMOTION"ì´ "NO PROMOTION"ì—ë„ ë§¤ì¹­ë¨ â†’ passSignals ìš°ì„  íŒë‹¨
            if (hasPassSignal && !hasRejectSignal) {
                isMatch = true;
            } else if (hasPassSignal && hasRejectSignal) {
                // ë‘˜ ë‹¤ ìˆìœ¼ë©´: "no promotion" íŒ¨í„´ì¸ì§€ í™•ì¸
                const noPromoPattern = /no\s+(visible\s+)?(promotion|promo|gift|model|person|people|banner|badge)/i;
                const hasNegation = noPromoPattern.test(response);
                const ì—†Pattern = /(í”„ë¡œëª¨ì…˜|ì¦ì •|ì‚¬ì€í’ˆ|ëª¨ë¸|ì‚¬ëŒ|ë°°ë„ˆ).{0,5}ì—†/;
                const hasì—† = ì—†Pattern.test(response);
                isMatch = hasNegation || hasì—†;
            } else {
                isMatch = false;
            }

            log(`      âš ï¸  MATCH í˜•ì‹ ì—†ìŒ â†’ fallback íŒŒì‹±: ${isMatch ? 'í†µê³¼' : 'ê±°ì ˆ'}`);
        }

        // âœ… v13: í”„ë¡œëª¨/ì‚¬ì€í’ˆ/ëª¨ë¸ ê°ì§€ ì‹œ ì œì™¸ (FIX-7)
        if (hasPromo) {
            log(`      âŒ ë„¤ì´ë²„ ì´ë¯¸ì§€: í”„ë¡œëª¨ì…˜ ë±ƒì§€/ë°°ë„ˆ ê°ì§€ë¨`);
            return { pass: false, reason: 'í”„ë¡œëª¨ì…˜ ë±ƒì§€/ë°°ë„ˆ í¬í•¨' };
        }
        if (hasGift) {
            log(`      âŒ ë„¤ì´ë²„ ì´ë¯¸ì§€: ì‚¬ì€í’ˆ/ì¦ì •í’ˆ ê°ì§€ë¨`);
            return { pass: false, reason: 'ì‚¬ì€í’ˆ/ì¦ì •í’ˆ í¬í•¨' };
        }
        if (hasModel) {
            log(`      âŒ ë„¤ì´ë²„ ì´ë¯¸ì§€: ëª¨ë¸/ì‚¬ëŒ ì‚¬ì§„ ê°ì§€ë¨`);
            return { pass: false, reason: 'ëª¨ë¸/ì‚¬ëŒ ì‚¬ì§„' };
        }

        return { pass: isMatch, reason };
    } catch (error) {
        log(`      âš ï¸ ë„¤ì´ë²„ ê²€ì¦ ì‹¤íŒ¨: ${error.message}`);
        return { pass: true, reason: 'API ì˜¤ë¥˜ - ê¸°ë³¸ í†µê³¼' };
    }
}

// ==================== ë„¤ì´ë²„ ì´ë¯¸ì§€ ê²€ìƒ‰ ====================
async function searchNaverImages(titleKr, maxImages = 15) {
    log(`\nğŸ” ë„¤ì´ë²„ ì´ë¯¸ì§€ ê²€ìƒ‰ ì‹œì‘: "${titleKr}"`);
    log(`   ëª©í‘œ: ì›ë³¸ ì´ë¯¸ì§€ ${maxImages}ê°œ ìˆ˜ì§‘`);

    const imageUrls = [];
    const seen = new Set();

    // URLì—ì„œ ì œì™¸í•  í‚¤ì›Œë“œ (ì•„ì´ì½˜/ë¡œê³ /ë°°ë„ˆ/ìŠ¤í”„ë¼ì´íŠ¸ ë“± ë¹„ìƒí’ˆ ì´ë¯¸ì§€)
    const excludeKeywords = ['logo', 'icon', 'sprite', 'favicon', 'avatar', 'btn_', 'button_', 'blogpfthumb'];
    const isExcludedUrl = (url) => {
        const lower = url.toLowerCase();
        return excludeKeywords.some(kw => lower.includes(kw));
    };

    // HTMLì—ì„œ ì´ë¯¸ì§€ URL ì¶”ì¶œí•˜ëŠ” ë‚´ë¶€ í•¨ìˆ˜
    const extractFromHtml = (html) => {
        let count = 0;
        let match;

        // 1ë‹¨ê³„: search.pstatic.net/?src= íŒ¨í„´ì—ì„œ ì›ë³¸ URL ì¶”ì¶œ
        const pstaticPattern = /https?:\/\/search\.pstatic\.net\/(?:common|sunny)\/\?src=([^"&\s\\]+)/g;
        while ((match = pstaticPattern.exec(html)) !== null) {
            try {
                let srcParam = match[1];
                srcParam = srcParam.replace(/&amp;/g, '&');
                // \u0026 ë“± ìœ ë‹ˆì½”ë“œ ì´ìŠ¤ì¼€ì´í”„ ì´í›„ ì œê±° (type íŒŒë¼ë¯¸í„° ë“±)
                srcParam = srcParam.replace(/\\u[0-9a-fA-F]{4}.*/g, '');
                const originalUrl = decodeURIComponent(srcParam);

                if (originalUrl.startsWith('http') && !seen.has(originalUrl) && !isExcludedUrl(originalUrl)) {
                    seen.add(originalUrl);
                    imageUrls.push(originalUrl);
                    count++;
                }
            } catch (e) {}
        }

        // 2ë‹¨ê³„: shopping-phinf.pstatic.net ì§ì ‘ URL ì¶”ì¶œ (ì‡¼í•‘ ì„¹ì…˜ ê³ í’ˆì§ˆ ì´ë¯¸ì§€)
        const shoppingPattern = /https?:\/\/shopping-phinf\.pstatic\.net\/[^"&\s\\]+/g;
        while ((match = shoppingPattern.exec(html)) !== null) {
            try {
                let url = match[0];
                url = url.replace(/\\u[0-9a-fA-F]{4}.*/g, '');
                if (url.startsWith('http') && !seen.has(url) && !isExcludedUrl(url)) {
                    seen.add(url);
                    imageUrls.push(url);
                    count++;
                }
            } catch (e) {}
        }

        return count;
    };

    const headers = {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
        'Accept-Language': 'ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7',
        'Referer': 'https://www.naver.com'
    };

    try {
        // 1ì°¨ ê²€ìƒ‰: ì›ë³¸ ì¿¼ë¦¬
        const searchUrl1 = `https://search.naver.com/search.naver?where=image&query=${encodeURIComponent(titleKr)}`;
        log(`   ğŸ”„ 1ì°¨ ê²€ìƒ‰: "${titleKr}"`);

        const response1 = await axios.get(searchUrl1, { headers, timeout: 15000 });
        log(`   âœ… HTML ìˆ˜ì‹  (${(response1.data.length / 1024).toFixed(1)}KB)`);

        const count1 = extractFromHtml(response1.data);
        log(`   âœ… 1ì°¨ ì¶”ì¶œ: ${count1}ê°œ`);

        // 2ì°¨ ê²€ìƒ‰: "ì œí’ˆ" í‚¤ì›Œë“œ ì¶”ê°€ (ë‹¤ì–‘í•œ ìƒí’ˆ ì´ë¯¸ì§€ í™•ë³´, ì¤‘ë³µ ì œì™¸)
        try {
            const searchUrl2 = `https://search.naver.com/search.naver?where=image&query=${encodeURIComponent(titleKr + ' ì œí’ˆ')}`;
            log(`   ğŸ”„ 2ì°¨ ê²€ìƒ‰: "${titleKr} ì œí’ˆ"`);

            const response2 = await axios.get(searchUrl2, { headers, timeout: 15000 });
            const count2 = extractFromHtml(response2.data);
            log(`   âœ… 2ì°¨ ì¶”ì¶œ: ${count2}ê°œ ì¶”ê°€ (ì¤‘ë³µ ì œì™¸)`);
        } catch (e2) {
            log(`   âš ï¸  2ì°¨ ê²€ìƒ‰ ì‹¤íŒ¨ (ë¬´ì‹œ): ${e2.message}`);
        }

        // 3ë‹¨ê³„: ìƒí’ˆ ì´ë¯¸ì§€ ìš°ì„  ì •ë ¬
        imageUrls.sort((a, b) => {
            const priority = (url) => {
                const l = url.toLowerCase();
                if (l.includes('shopping-phinf.pstatic.net')) return 0;  // ë„¤ì´ë²„ ì‡¼í•‘ ê³µì‹ (í°ë°°ê²½)
                if (l.includes('shop-phinf.pstatic.net')) return 1;     // ë„¤ì´ë²„ ìŠ¤ë§ˆíŠ¸ìŠ¤í† ì–´
                if (l.includes('shop1.phinf.naver.net')) return 2;      // ë„¤ì´ë²„ ìŠ¤ë§ˆíŠ¸ìŠ¤í† ì–´ (êµ¬í˜•)
                if (l.includes('.pstatic.net')) return 3;               // ê¸°íƒ€ pstatic CDN
                if (l.includes('blogfiles.naver.net')) return 8;        // ë¸”ë¡œê·¸ (í›„ìˆœìœ„)
                if (l.includes('cafefiles')) return 9;                  // ì¹´í˜ (ìµœí›„ìˆœìœ„)
                return 5;                                               // ì™¸ë¶€ ë„ë©”ì¸
            };
            return priority(a) - priority(b);
        });

        // ë„ë©”ì¸ë³„ í†µê³„
        const domainStats = {};
        imageUrls.forEach(url => {
            try {
                const domain = new URL(url).hostname;
                domainStats[domain] = (domainStats[domain] || 0) + 1;
            } catch (e) {}
        });
        const topDomains = Object.entries(domainStats).sort((a, b) => b[1] - a[1]).slice(0, 5);
        log(`   ğŸ“Š ë„ë©”ì¸ ë¶„í¬: ${topDomains.map(([d, c]) => `${d}(${c})`).join(', ')}`);

        // ë¡œê·¸: ì¶”ì¶œëœ URL ëª©ë¡ (ì •ë ¬ í›„)
        if (imageUrls.length > 0) {
            log(`\n   ğŸ“‹ ì¶”ì¶œëœ URL (${Math.min(imageUrls.length, maxImages)}/${imageUrls.length}ê°œ):`);
            imageUrls.slice(0, maxImages).forEach((url, i) => {
                log(`      ${i + 1}. ${url.substring(0, 80)}...`);
            });
        }

    } catch (error) {
        log(`   âŒ ë„¤ì´ë²„ ê²€ìƒ‰ ì˜¤ë¥˜: ${error.message}`);
    }

    // maxImages ì œí•œ ì ìš© (ì •ë ¬ í›„ ìƒìœ„ Nê°œ)
    const result = imageUrls.slice(0, maxImages);
    log(`\n   âœ… ìµœì¢… ìˆ˜ì§‘: ${result.length}ê°œ ì›ë³¸ ì´ë¯¸ì§€`);
    return result;
}

// ==================== ì´ë¯¸ì§€ í¬ê¸° í™•ì¸ ====================
async function getImageDimensions(imagePath) {
    const pythonScript = `/tmp/get_dims_${Date.now()}.py`;
    const script = `import cv2
img = cv2.imread('${imagePath}')
if img is not None:
    h, w = img.shape[:2]
    print(f'{w},{h}')
`;
    
    fs.writeFileSync(pythonScript, script);
    
    try {
        const { stdout } = await execAsync(`${PYTHON_PATH} "${pythonScript}"`);
        cleanupFiles(pythonScript);
        
        const [width, height] = stdout.trim().split(',').map(Number);
        
        if (!width || !height) return null;
        
        return { width, height };
        
    } catch (error) {
        cleanupFiles(pythonScript);
        return null;
    }
}

// ==================== Gemini í¬ë¡­ ì¢Œí‘œ ìš”ì²­ ====================
async function getCropCoordinates(imageUrl, productTitle, imageWidth, imageHeight) {
    try {
        log(`      ğŸ” í¬ë¡­ ì¢Œí‘œ ìš”ì²­ ì¤‘...`);
        
        const response = await axios.get(imageUrl, {
            responseType: 'arraybuffer',
            timeout: 30000,
            headers: {
                'User-Agent': 'Mozilla/5.0',
                'Referer': 'https://www.naver.com'
            }
        });
        const base64 = Buffer.from(response.data).toString('base64');
        
        const model = genAI.getGenerativeModel({ model: 'gemini-2.0-flash' });
        
        const isSetProduct = /set of \d+|ì„¸íŠ¸|\d+ê°œì…|\d+ê°œ ì„¸íŠ¸|(\d+)\s*pcs?/i.test(productTitle);

        const prompt = `ì´ ì´ë¯¸ì§€ì—ì„œ "${productTitle}" ì œí’ˆì˜ ë³¸ì²´ë§Œ ì°¾ì•„ì£¼ì„¸ìš”.

ì´ë¯¸ì§€ í¬ê¸°: ${imageWidth}x${imageHeight} í”½ì…€
${isSetProduct ? 'ì„¸íŠ¸ ì œí’ˆ: ëª¨ë“  ì œí’ˆì„ í¬í•¨' : 'ë‹¨ì¼ ì œí’ˆ: 1ê°œë§Œ ì„ íƒ'}

ì œí’ˆ ë³¸ì²´ë§Œ í¬í•¨ (í¬ì¥ë°•ìŠ¤ ì œì™¸)

JSON í˜•ì‹ìœ¼ë¡œë§Œ ë‹µë³€:
{
  "found": true,
  "x": í”½ì…€_xì¢Œí‘œ,
  "y": í”½ì…€_yì¢Œí‘œ,
  "width": í”½ì…€_ë„ˆë¹„,
  "height": í”½ì…€_ë†’ì´
}`;

        const result = await model.generateContent([
            prompt,
            { inlineData: { data: base64, mimeType: 'image/jpeg' } }
        ]);
        
        // Gemini API í˜¸ì¶œ ì¶”ì 
        trackGeminiCall('getCropCoordinates_Naver');

        const responseText = result.response.text();
        
        const jsonMatch = responseText.match(/\{[\s\S]*\}/);
        if (jsonMatch) {
            const coords = JSON.parse(jsonMatch[0]);
            if (coords.found) {
                log(`      ğŸ“ ì¢Œí‘œ: (${coords.x}, ${coords.y}) ${coords.width}x${coords.height}`);
            }
            return coords;
        }
        
        return null;
        
    } catch (error) {
        log('      âŒ í¬ë¡­ ì¢Œí‘œ ìš”ì²­ ì‹¤íŒ¨:', error.message);
        return null;
    }
}

// ==================== ì¢Œí‘œ í™•ì¥ ====================
function expandCoordinates(coords, imageWidth, imageHeight, expandRatio = 0.2) {
    const expandWidth = coords.width * expandRatio;
    const expandHeight = coords.height * expandRatio;
    
    let newX = Math.round(coords.x - expandWidth / 2);
    let newY = Math.round(coords.y - expandHeight / 2);
    let newWidth = Math.round(coords.width * (1 + expandRatio));
    let newHeight = Math.round(coords.height * (1 + expandRatio));
    
    newX = Math.max(0, newX);
    newY = Math.max(0, newY);
    newWidth = Math.min(newWidth, imageWidth - newX);
    newHeight = Math.min(newHeight, imageHeight - newY);
    
    return { x: newX, y: newY, width: newWidth, height: newHeight };
}

// ==================== ì´ë¯¸ì§€ í¬ë¡­ ====================
async function cropImage(inputPath, outputPath, x, y, width, height) {
    const pythonScript = `/tmp/crop_${Date.now()}.py`;
    const script = `import cv2
img = cv2.imread('${inputPath}')
if img is not None:
    h, w = img.shape[:2]
    x = max(0, min(${x}, w))
    y = max(0, min(${y}, h))
    width = min(${width}, w - x)
    height = min(${height}, h - y)
    cropped = img[y:y+height, x:x+width]
    cv2.imwrite('${outputPath}', cropped)
`;
    
    fs.writeFileSync(pythonScript, script);
    
    try {
        await execAsync(`${PYTHON_PATH} "${pythonScript}"`);
        cleanupFiles(pythonScript);
        
        if (fs.existsSync(outputPath)) {
            log(`      âœ… í¬ë¡­ ì™„ë£Œ`);
            return true;
        }
        return false;
        
    } catch (error) {
        cleanupFiles(pythonScript);
        return false;
    }
}

// ==================== ë°°ê²½ ì œê±° + í°ìƒ‰ ë°°ê²½ ====================
async function removeBackgroundAndAddWhite(inputPath, outputPath) {
    log(`      ğŸ¨ ë°°ê²½ ì œê±° + í°ìƒ‰ ë°°ê²½ ì¤‘...`);
    
    try {
        const tempTransparent = outputPath.replace('.png', '_temp.png');
        
        await execAsync(`${REMBG_PATH} i "${inputPath}" "${tempTransparent}"`);
        
        if (!fs.existsSync(tempTransparent)) {
            return false;
        }
        
        const pythonScript = `/tmp/add_white_${Date.now()}.py`;
        const pythonCode = `from PIL import Image
img = Image.open('${tempTransparent}').convert('RGBA')
white_bg = Image.new('RGBA', img.size, (255, 255, 255, 255))
white_bg.paste(img, (0, 0), img)
white_bg.convert('RGB').save('${outputPath}', 'PNG')
`;
        
        fs.writeFileSync(pythonScript, pythonCode);
        await execAsync(`${PYTHON_PATH} "${pythonScript}"`);
        
        cleanupFiles(tempTransparent, pythonScript);
        
        if (fs.existsSync(outputPath)) {
            log(`      âœ… ì™„ë£Œ!`);
            return true;
        }
        return false;
        
    } catch (error) {
        log('      âŒ rembg ì‹¤íŒ¨:', error.message);
        return false;
    }
}

// ==================== ì œí’ˆ ì²˜ë¦¬ (í•µì‹¬) ====================
async function processProduct(product, productIndex, totalProducts) {
    const { Id, validated_images } = product;
    
    log(`\n${'='.repeat(70)}`);
    log(`ğŸ“¦ ì œí’ˆ ${productIndex}/${totalProducts} - ID: ${Id}`);
    
    log(`\nğŸ—‘ï¸  Step 0: ì´ˆê¸°í™”`);
    
    try {
        await axios.patch(
            `${NOCODB_API_URL}/api/v2/tables/${SHOPIFY_TABLE_ID}/records`,
            [{ Id: Id, main_image: null, gallery_images: null }],  // âœ… v11: ë°°ì—´ ë˜í¼
            { headers: { 'xc-token': NOCODB_API_TOKEN, 'Content-Type': 'application/json' } }
        );
        log(`   âœ… ì´ˆê¸°í™” ì™„ë£Œ!\n`);
    } catch (error) {
        log(`   âŒ ì´ˆê¸°í™” ì‹¤íŒ¨:`, error.message);
        return;
    }
    
    log(`ğŸ” Step 1: ì œí’ˆ ì •ë³´ ì¡°íšŒ`);
    
    const oliveyoungProduct = await getOliveyoungProduct(Id);
    
    let productTitle = 'Unknown Product';
    let titleKr = 'Unknown Product';
    if (oliveyoungProduct) {
        productTitle = oliveyoungProduct.title_en || oliveyoungProduct.title_kr || 'Unknown Product';
        titleKr = oliveyoungProduct.title_kr || 'Unknown Product';
        log(`âœ… ì œí’ˆëª… (EN): ${productTitle}`);
        log(`âœ… ì œí’ˆëª… (KR): ${titleKr}`);
    }
    
    const productInfo = extractProductInfo(productTitle);

    // âœ… v14: set_count í•„ë“œ ìš°ì„  ì°¸ì¡°, ì—†ìœ¼ë©´ ê¸°ì¡´ íƒ€ì´í‹€ íŒŒì‹± ì‚¬ìš©
    if (oliveyoungProduct && oliveyoungProduct.set_count && oliveyoungProduct.set_count > 1) {
        productInfo.setCount = oliveyoungProduct.set_count;
        productInfo.isSetProduct = true;
        log(`ğŸ“‹ ì œí’ˆ ì •ë³´ (set_count: ${oliveyoungProduct.set_count}):`);
    } else {
        log(`ğŸ“‹ ì œí’ˆ ì •ë³´:`);
    }
    log(`   - ë¸Œëœë“œ: ${productInfo.brandName || 'N/A'}`);
    log(`   - ì œí’ˆ ë¼ì¸: ${productInfo.productLineName || 'N/A'}`);
    log(`   - ìš©ëŸ‰: ${productInfo.volume || 'N/A'}`);
    log(`   - ì„¸íŠ¸: ${productInfo.isSetProduct ? 'âœ…' : 'âŒ'}`);
    
    if (!validated_images || validated_images.length === 0) {
        log('âš ï¸  validated_images ì—†ìŒ');
        return;
    }
    
    log(`ğŸ“¸ ê²€ì¦ëœ ì´ë¯¸ì§€: ${validated_images.length}ê°œ\n`);
    
    log(`ğŸ“Š Step 2: ì´ë¯¸ì§€ í‰ê°€ (v12 í†µí•© API ë²„ì „)`);
    log(`${'â”€'.repeat(70)}`);
    
    const scoredImages = [];
    
    for (let i = 0; i < validated_images.length; i++) {
        const img = validated_images[i];
        
        let imageUrl = img.url;
        if (!imageUrl && img.path) {
            imageUrl = `${NOCODB_API_URL}/${img.path}`;
        }
        
        if (!imageUrl) continue;
        
        const tempPath = `/tmp/score-${Id}-${i}-${Date.now()}.png`;
        
        try {
            await downloadImage(imageUrl, tempPath);
            
            const scored = await scoreImage(img, tempPath, productTitle, productInfo, i);
            scoredImages.push(scored);
            
            if (i < validated_images.length - 1) {
                log(`\n      â³ 4ì´ˆ ëŒ€ê¸°...`);
                await new Promise(resolve => setTimeout(resolve, 4000));
            }
            
        } catch (error) {
            log(`\n   âŒ ì´ë¯¸ì§€ ${i + 1} í‰ê°€ ì‹¤íŒ¨:`, error.message);
            cleanupFiles(tempPath);
        }
    }
    
    if (scoredImages.length === 0) {
        log('\nâš ï¸  í‰ê°€ëœ ì´ë¯¸ì§€ ì—†ìŒ');
        return;
    }
    
    scoredImages.sort((a, b) => b.totalScore - a.totalScore);

    // âœ… v14: ìœ ì‚¬ ì´ë¯¸ì§€ ì¤‘ë³µ ì œê±°
    const uniqueImages = removeSimilarImages(scoredImages);

    log(`\nğŸ“Š í‰ê°€ ê²°ê³¼ (ì ìˆ˜ìˆœ, ìœ ì‚¬ ì œê±° í›„):`);
    uniqueImages.forEach((img, idx) => {
        log(`   ${idx + 1}ìœ„: ${img.totalScore}/125ì  (ê°ì : ${img.scores.penalties})`);
    });

    log(`\nâœ‚ï¸  Step 3: ìƒìœ„ 3ê°œ ì„ ë³„`);
    
    // âœ… v12: ì ìˆ˜ ê¸°ë°˜ ì„ ë³„ (MIN_SCORE_FOR_MAIN, MIN_SCORE_FOR_GALLERY)
    if (uniqueImages[0].totalScore < MIN_SCORE_FOR_MAIN) {
        log(`   âš ï¸  ìµœê³ ì  ${uniqueImages[0].totalScore}ì  < ìµœì†Œ ${MIN_SCORE_FOR_MAIN}ì  â†’ í’ˆì§ˆ ë¯¸ë‹¬`);
    }

    const selectedForSave = [];
    for (const img of uniqueImages.slice(0, 3)) {
        if (selectedForSave.length === 0) {
            // ë©”ì¸ ì´ë¯¸ì§€: MIN_SCORE_FOR_MAIN ì´ìƒ
            if (img.totalScore >= MIN_SCORE_FOR_MAIN) {
                selectedForSave.push(img);
            }
        } else {
            // ê°¤ëŸ¬ë¦¬ ì´ë¯¸ì§€: MIN_SCORE_FOR_GALLERY ì´ìƒ
            if (img.totalScore >= MIN_SCORE_FOR_GALLERY) {
                selectedForSave.push(img);
            }
        }
    }
    
    log(`   ì„ ë³„ë¨: ${selectedForSave.length}ê°œ (ë©”ì¸ ìµœì†Œ: ${MIN_SCORE_FOR_MAIN}ì , ê°¤ëŸ¬ë¦¬ ìµœì†Œ: ${MIN_SCORE_FOR_GALLERY}ì )`);
    
    log(`\nğŸ“ Step 4: ì •ê·œí™” + ì—…ë¡œë“œ`);
    
    const processedImages = [];
    
    for (let i = 0; i < selectedForSave.length; i++) {
        const selected = selectedForSave[i];
        
        log(`\n   ${i + 1}/${selectedForSave.length} ì²˜ë¦¬ ì¤‘...`);
        
        if (!selected || !selected.imagePath || !fs.existsSync(selected.imagePath)) {
            log('      âŒ ìœ íš¨í•˜ì§€ ì•Šì€ ì´ë¯¸ì§€');
            continue;
        }
        
        const normalizedPath = normalizeImage(selected.imagePath);
        if (!normalizedPath || !fs.existsSync(normalizedPath)) {
            log('      âŒ ì •ê·œí™” ì‹¤íŒ¨');
            cleanupFiles(selected.imagePath);
            continue;
        }
        
        try {
            log('      ğŸ“¤ NocoDB ì—…ë¡œë“œ ì¤‘...');
            const fileName = `final-${Id}-${i + 1}-${Date.now()}.png`;
            const uploadResult = await uploadToNocoDB(normalizedPath, fileName);
            
            if (uploadResult && uploadResult.length > 0) {
                processedImages.push(uploadResult[0]);
                log('      âœ… ì™„ë£Œ!');
            }
        } catch (uploadError) {
            log('      âŒ ì—…ë¡œë“œ ì˜¤ë¥˜:', uploadError.message);
        }
        
        cleanupFiles(selected.imagePath, normalizedPath);
    }
    
    if (processedImages.length === 0) {
        log('\nâš ï¸  ì²˜ë¦¬ëœ ì´ë¯¸ì§€ ì—†ìŒ');
        scoredImages.forEach(img => cleanupFiles(img.imagePath));
        return;
    }
    
    log(`\nğŸ’¾ Step 5: DB ì €ì¥`);
    
    const mainImage = processedImages[0];
    const galleryImages = processedImages.slice(1);
    const madeAt = new Date().toISOString();
    
    try {
        await axios.patch(
            `${NOCODB_API_URL}/api/v2/tables/${SHOPIFY_TABLE_ID}/records`,
            [{  // âœ… v11: ë°°ì—´ ë˜í¼
                Id: Id,
                main_image: [mainImage],
                gallery_images: galleryImages.length > 0 ? galleryImages : null,
                made_at: madeAt
            }],
            { headers: { 'xc-token': NOCODB_API_TOKEN, 'Content-Type': 'application/json' } }
        );
        
        log(`âœ… ì €ì¥ ì™„ë£Œ!`);
        log(`   - main_image: 1ê°œ`);
        log(`   - gallery_images: ${galleryImages.length}ê°œ`);
    } catch (error) {
        log(`âŒ ì €ì¥ ì‹¤íŒ¨:`, error.message);
        scoredImages.forEach(img => cleanupFiles(img.imagePath));
        return;
    }
    
    scoredImages.forEach(img => cleanupFiles(img.imagePath));
    
    // Step 6: DB í™•ì¸
    log(`\nğŸ” Step 6: DB í™•ì¸`);
    
    let actualMainCount = 0;
    let actualGalleryCount = 0;
    
    try {
        const verifyResponse = await axios.get(
            `${NOCODB_API_URL}/api/v2/tables/${SHOPIFY_TABLE_ID}/records`,
            { headers: { 'xc-token': NOCODB_API_TOKEN }, params: { where: `(Id,eq,${Id})` } }
        );
        
        if (verifyResponse.data.list.length > 0) {
            const savedProduct = verifyResponse.data.list[0];
            actualMainCount = savedProduct.main_image?.length > 0 ? 1 : 0;
            actualGalleryCount = savedProduct.gallery_images?.length || 0;
            
            log(`   - Main: ${actualMainCount}ê°œ`);
            log(`   - Gallery: ${actualGalleryCount}ê°œ`);
        }
    } catch (error) {
        actualMainCount = 1;
        actualGalleryCount = galleryImages.length;
    }
    
    const totalCount = actualMainCount + actualGalleryCount;
    
    if (totalCount >= 3) {
        log(`\nâœ… ì¶©ë¶„í•¨! (${totalCount}/3ê°œ)`);
        return;
    }
    
    log(`\nâš ï¸  ë¶€ì¡±í•¨! (${totalCount}/3ê°œ) â†’ ë„¤ì´ë²„ ë³´ì¶©`);
    const needed = 3 - totalCount;
    
    // ë„¤ì´ë²„ ë³´ì¶© ë¡œì§
    log(`\nğŸŒ Step 7: ë„¤ì´ë²„ ê²€ìƒ‰`);
    
    const naverUrls = await searchNaverImages(titleKr, needed === 1 ? 10 : 15);
    
    if (naverUrls.length === 0) {
        log(`   âŒ ë„¤ì´ë²„ ì´ë¯¸ì§€ ì—†ìŒ`);
        return;
    }
    
    // âœ… v14: validated_images URL ëª©ë¡ìœ¼ë¡œ ì¤‘ë³µ ì²´í¬
    const existingUrls = (validated_images || []).map(img => {
        const u = img.originalUrl || img.url || '';
        return u.toLowerCase();
    });

    const filteredUrls = naverUrls.filter(url => {
        const lowerUrl = url.toLowerCase();
        // ì˜¬ë¦¬ë¸Œì˜ CDN íŒ¨í„´ í™•ì¥ í•„í„°
        if (lowerUrl.includes('oliveyoung') || lowerUrl.includes('image.oliveyoung') || lowerUrl.includes('image-oliveyoung')) return false;
        if (lowerUrl.includes('small') || lowerUrl.includes('thumb')) return false;
        if (lowerUrl.includes('box') || lowerUrl.includes('íŒ¨í‚¤ì§€')) return false;
        // âœ… v15: ì¶”ê°€ ë§ˆì¼“í”Œë ˆì´ìŠ¤/í”„ë¡œëª¨ CDN í•„í„°
        if (lowerUrl.includes('coupang') || lowerUrl.includes('11st.co.kr') || lowerUrl.includes('gmarket')) return false;
        if (lowerUrl.includes('tmon') || lowerUrl.includes('wemakeprice') || lowerUrl.includes('auction.co.kr')) return false;
        if (lowerUrl.includes('promotion') || lowerUrl.includes('event') || lowerUrl.includes('banner')) return false;
        if (lowerUrl.includes('blog') || lowerUrl.includes('cafe.naver') || lowerUrl.includes('review')) return false;
        // ê¸°ì¡´ validated_imagesì™€ ë™ì¼ URL ìŠ¤í‚µ
        if (existingUrls.some(eu => eu && (eu.includes(lowerUrl) || lowerUrl.includes(eu)))) return false;
        return true;
    });

    log(`   ğŸ“Š ë„¤ì´ë²„ URL í•„í„°: ${naverUrls.length}ê°œ â†’ ${filteredUrls.length}ê°œ (${naverUrls.length - filteredUrls.length}ê°œ ì œì™¸)`);

    log(`\nğŸ–¼ï¸  Step 8: ë„¤ì´ë²„ ì²˜ë¦¬`);
    
    const naverProcessed = [];
    
    for (let i = 0; i < Math.min(filteredUrls.length, needed + 2); i++) {
        const imageUrl = filteredUrls[i];
        
        log(`\n   ë„¤ì´ë²„ ${i + 1}: ${imageUrl.substring(0, 60)}...`);
        
        const timestamp = Date.now();
        const inputPath = `/tmp/naver-${timestamp}-${i}.jpg`;
        const croppedPath = `/tmp/naver-crop-${timestamp}-${i}.png`;
        const finalPath = `/tmp/naver-final-${timestamp}-${i}.png`;
        
        try {
            await downloadImage(imageUrl, inputPath);
            
            const dimensions = await getImageDimensions(inputPath);
            if (!dimensions || dimensions.width < 400 || dimensions.height < 400) {
                cleanupFiles(inputPath);
                continue;
            }
            
            const coords = await getCropCoordinates(imageUrl, productTitle, dimensions.width, dimensions.height);

            let processPath = inputPath;

            if (coords && coords.found) {
                // âœ… v11: í¬ë¡­ ì¢Œí‘œ ê²€ì¦ - ì›ë³¸ì˜ 20% ë¯¸ë§Œì´ë©´ ê±´ë„ˆë›°ê¸°
                if (coords.width < dimensions.width * 0.2 || coords.height < dimensions.height * 0.2) {
                    log(`      âš ï¸  í¬ë¡­ ì¢Œí‘œê°€ ì›ë³¸ì˜ 20% ë¯¸ë§Œ (${coords.width}x${coords.height} vs ${dimensions.width}x${dimensions.height}) â†’ ì›ë³¸ ê·¸ëŒ€ë¡œ ì‚¬ìš©`);
                } else {
                    const expanded = expandCoordinates(coords, dimensions.width, dimensions.height, 0.2);
                    const cropSuccess = await cropImage(inputPath, croppedPath, expanded.x, expanded.y, expanded.width, expanded.height);
                    if (cropSuccess) {
                        // âœ… v11: í¬ë¡­ í›„ í¬ê¸° ê²€ì¦
                        const croppedDimensions = await getImageDimensions(croppedPath);
                        if (croppedDimensions) {
                            const widthRatio = croppedDimensions.width / dimensions.width;
                            const heightRatio = croppedDimensions.height / dimensions.height;
                            const aspectRatio = croppedDimensions.width / croppedDimensions.height;

                            // í¬ë¡­ ê²°ê³¼ê°€ ì›ë³¸ì˜ 15% ë¯¸ë§Œì´ë©´ íê¸°
                            if (widthRatio < 0.15 || heightRatio < 0.15) {
                                log(`      âš ï¸  í¬ë¡­ ê²°ê³¼ ë„ˆë¬´ ì‘ìŒ (${(widthRatio * 100).toFixed(1)}%x${(heightRatio * 100).toFixed(1)}%) â†’ ì›ë³¸ ì‚¬ìš©`);
                            // ì¢…íš¡ë¹„ê°€ ê·¹ë‹¨ì ì´ë©´ (> 4:1 ë˜ëŠ” < 1:4) íê¸°
                            } else if (aspectRatio > 4 || aspectRatio < 0.25) {
                                log(`      âš ï¸  í¬ë¡­ ì¢…íš¡ë¹„ ê·¹ë‹¨ì  (${aspectRatio.toFixed(2)}) â†’ ì›ë³¸ ì‚¬ìš©`);
                            } else {
                                processPath = croppedPath;
                            }
                        }
                    }
                }
            }
            
            const rembgSuccess = await removeBackgroundAndAddWhite(processPath, finalPath);

            if (rembgSuccess) {
                // âœ… v12: rembg í›„ íŒŒì¼ í¬ê¸° 10KB ë¯¸ë§Œì´ë©´ ê±´ë„ˆë›°ê¸°
                const fileSize = fs.statSync(finalPath).size;
                if (fileSize < 10240) {
                    log(`      âš ï¸  íŒŒì¼ í¬ê¸° ë„ˆë¬´ ì‘ìŒ (${(fileSize/1024).toFixed(1)}KB) â†’ ê±´ë„ˆë›°ê¸°`);
                    cleanupFiles(inputPath, croppedPath, finalPath);
                    continue;
                }

                // âœ… v11: ë„¤ì´ë²„ ì´ë¯¸ì§€ ê¸°ë³¸ ê²€ì¦
                const naverCheck = await quickNaverImageCheck(finalPath, productInfo);
                if (!naverCheck.pass) {
                    log(`      âŒ ë„¤ì´ë²„ ì´ë¯¸ì§€ ê²€ì¦ ì‹¤íŒ¨: ${naverCheck.reason}`);
                    cleanupFiles(inputPath, croppedPath, finalPath);
                    continue;
                }

                // âœ… v14: ê¸°ë³¸ ë¶„ì„ìœ¼ë¡œ í•´ìƒë„/ì™„ì„±ë„/í¬ì¥ë°•ìŠ¤ ì²´í¬
                const naverBasics = await analyzeImageBasics(finalPath, productTitle, productInfo);
                const naverResolution = getImageResolution(finalPath);
                const naverResScore = calculateResolutionScore(naverResolution);
                if (naverResScore < 15) {
                    log(`      âŒ ë„¤ì´ë²„ ì´ë¯¸ì§€ í•´ìƒë„ ë¶€ì¡±: ${naverResScore}/30ì  â†’ ê±´ë„ˆë›°ê¸°`);
                    cleanupFiles(inputPath, croppedPath, finalPath);
                    continue;
                }
                if (naverBasics.productNotVisible) {
                    log(`      âŒ ë„¤ì´ë²„ ì´ë¯¸ì§€ ì œí’ˆ ë¯¸í™•ì¸ â†’ ê±´ë„ˆë›°ê¸°`);
                    cleanupFiles(inputPath, croppedPath, finalPath);
                    continue;
                }

                const fileName = `naver-${Id}-${i + 1}-${timestamp}.png`;
                const uploadedData = await uploadToNocoDB(finalPath, fileName);
                naverProcessed.push(uploadedData[0]);
                log(`      âœ… ì €ì¥!`);
            }
            
            cleanupFiles(inputPath, croppedPath, finalPath);
            
        } catch (error) {
            log(`      âŒ ì‹¤íŒ¨:`, error.message);
            cleanupFiles(inputPath, croppedPath, finalPath);
        }
        
        if (naverProcessed.length >= needed) break;
        
        // âœ… ë„¤ì´ë²„ ì´ë¯¸ì§€ ê°„ ëŒ€ê¸° 4ì´ˆ
        await new Promise(resolve => setTimeout(resolve, 4000));
    }

    if (naverProcessed.length === 0) {
        log(`\nâš ï¸  ë„¤ì´ë²„ ì´ë¯¸ì§€ ì²˜ë¦¬ ì‹¤íŒ¨`);
        return;
    }
    
    // Gallery ì—…ë°ì´íŠ¸
    log(`\nâ• Step 9: Gallery ì¶”ê°€`);
    
    let currentGallery = [];
    try {
        const currentResponse = await axios.get(
            `${NOCODB_API_URL}/api/v2/tables/${SHOPIFY_TABLE_ID}/records`,
            { headers: { 'xc-token': NOCODB_API_TOKEN }, params: { where: `(Id,eq,${Id})` } }
        );
        
        if (currentResponse.data.list.length > 0) {
            currentGallery = currentResponse.data.list[0].gallery_images || [];
        }
    } catch (error) {}
    
    const updatedGallery = [...currentGallery, ...naverProcessed.slice(0, needed)];
    
    try {
        await axios.patch(
            `${NOCODB_API_URL}/api/v2/tables/${SHOPIFY_TABLE_ID}/records`,
            [{ Id: Id, gallery_images: updatedGallery }],  // âœ… v11: ë°°ì—´ ë˜í¼
            { headers: { 'xc-token': NOCODB_API_TOKEN, 'Content-Type': 'application/json' } }
        );
        
        log(`âœ… Gallery ì—…ë°ì´íŠ¸: ${updatedGallery.length}ê°œ`);
        
    } catch (error) {
        log(`âŒ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨:`, error.message);
    }
}

// ==================== ë©”ì¸ ====================
async function main() {
    try {
        log('\nğŸ“¥ NocoDBì—ì„œ ì œí’ˆ ê°€ì ¸ì˜¤ëŠ” ì¤‘...\n');
        
        const products = await getProductsFromNocoDB();
        
        if (!products || products.length === 0) {
            log('âŒ ì²˜ë¦¬í•  ì œí’ˆì´ ì—†ìŠµë‹ˆë‹¤.');
            return;
        }
        
        log(`âœ… ${products.length}ê°œ ì œí’ˆ ë°œê²¬\n`);
        
        for (let i = 0; i < products.length; i++) {
            try {
                await processProduct(products[i], i + 1, products.length);
                
                if (i < products.length - 1) {
                    log(`\n${'='.repeat(70)}`);
                    log('â³ ë‹¤ìŒ ì œí’ˆ 7ì´ˆ ëŒ€ê¸°...\n');
                    await new Promise(resolve => setTimeout(resolve, 7000));
                }
            } catch (productError) {
                log(`\nâŒ ì œí’ˆ ${i + 1} ì˜¤ë¥˜:`, productError.message);
            }
        }
        
        log(`\n${'='.repeat(70)}`);
        log('ğŸ‰ Phase 4 v12 ë¨¸ì§€ ì™„ë£Œ!');
        log('='.repeat(70));
        log(`\nâœ¨ v12 í•µì‹¬ ë³€ê²½ (v11 ìµœì í™” ìœ ì§€):`);
        log('   âœ… Gemini API í†µí•©: 6â†’2íšŒ');
        log('   âœ… Gallery ìµœì†Œ ì ìˆ˜: 50 â†’ 60');
        log('   âœ… Main ìµœì†Œ ì ìˆ˜: 35 (ì‹ ê·œ)');
        log('   âœ… ë¯¸í™•ì¸ í•­ëª© ë™ì •ì ìˆ˜: 5 â†’ 2');
        log('   âœ… ê°œë³„ì œí’ˆ í¬ì¥ë°•ìŠ¤: -15 â†’ -30');
        log('   âœ… ì´ë¯¸ ì²˜ë¦¬ëœ ì œí’ˆ ì¬ì²˜ë¦¬ ë°©ì§€');
        log('   âœ… ë„¤ì´ë²„ rembg 10KB ë¯¸ë§Œ ê±´ë„ˆë›°ê¸°');
        log('   âœ… ìš©ëŸ‰ ë¶ˆì¼ì¹˜: í•˜ë“œíƒˆë½ â†’ -30 ê°ì \n');
        
        // Gemini API í˜¸ì¶œ í†µê³„ ì¶œë ¥
        geminiCounter.printSummary();
        
    } catch (error) {
        log('\nâŒ ì˜¤ë¥˜:', error.message);
    }
}


// Graceful shutdown
process.on('SIGINT', () => {
    log('');
    log('âš ï¸  SIGINT ìˆ˜ì‹  - ì•ˆì „í•˜ê²Œ ì¢…ë£Œ ì¤‘...');
    logStream.end();
    process.exit(0);
});

process.on('SIGTERM', () => {
    log('');
    log('âš ï¸  SIGTERM ìˆ˜ì‹  - ì•ˆì „í•˜ê²Œ ì¢…ë£Œ ì¤‘...');
    logStream.end();
    process.exit(0);
});

// ì‹¤í–‰
main().finally(() => logStream.end());