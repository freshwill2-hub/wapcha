import express from 'express';
import { createServer } from 'http';
import { Server } from 'socket.io';
import { spawn, execSync } from 'child_process';  // âœ… execSync ì¶”ê°€
import cron from 'node-cron';
import axios from 'axios';
import { v4 as uuidv4 } from 'uuid';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import dotenv from 'dotenv';
import ExcelJS from 'exceljs';

dotenv.config({ path: './.env' });

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// ==================== ì„¤ì • ====================
const PORT = process.env.DASHBOARD_PORT || 3000;
const NOCODB_API_URL = process.env.NOCODB_API_URL || 'http://77.42.67.165:8080';
const NOCODB_API_TOKEN = process.env.NOCODB_API_TOKEN;
const OLIVEYOUNG_TABLE_ID = process.env.OLIVEYOUNG_TABLE_ID;
const SHOPIFY_TABLE_ID = process.env.SHOPIFY_TABLE_ID;
const SCRIPTS_DIR = process.env.SCRIPTS_DIR || '/root/copychu-scraper';
const SHOPIFY_STORE_URL = process.env.SHOPIFY_STORE_URL || 'wap-australia-2.myshopify.com';
const SHOPIFY_ACCESS_TOKEN = process.env.SHOPIFY_ACCESS_TOKEN;
const SHOPIFY_API_VERSION = '2024-01';

console.log('ðŸ”§ í™˜ê²½ ë³€ìˆ˜ í™•ì¸:');
console.log(`- NOCODB_API_URL: ${NOCODB_API_URL}`);
console.log(`- OLIVEYOUNG_TABLE_ID: ${OLIVEYOUNG_TABLE_ID}`);
console.log(`- SHOPIFY_TABLE_ID: ${SHOPIFY_TABLE_ID}`);
console.log(`- SCRIPTS_DIR: ${SCRIPTS_DIR}`);

// ==================== Express + Socket.io ====================
const app = express();
const httpServer = createServer(app);
const io = new Server(httpServer, {
    cors: { origin: '*' }
});

app.use(express.json());
app.use(express.static(path.join(__dirname, 'public')));

// ==================== ìƒíƒœ ê´€ë¦¬ ====================
let systemState = {
    status: 'idle', // idle, running, paused, error
    currentPhase: null,
    currentProduct: 0,
    totalProducts: 0,
    startTime: null,
    pausedAt: null,
    errors: [],
    stats: {
        totalProcessed: 0,
        successCount: 0,
        failedCount: 0,
        apiCalls: 0,
        estimatedCost: 0
    }
};

let currentProcess = null;
let isPaused = false;
let scheduledJobs = [];

// ì„¤ì • ì €ìž¥ íŒŒì¼
const CONFIG_FILE = path.join(__dirname, 'config.json');

// ê¸°ë³¸ ì„¤ì •
let config = {
    productLimit: 3,
    oliveyoungUrl: '',
    minScoreForGallery: 60,
    minScoreForMain: 35,
    targetImageSize: 1200,
    productRatio: 0.75,
    geminiApiKey: '',
    maxVolumeLimit: 700,  // âœ… v2.9: ìš©ëŸ‰ ì œí•œ (ml) - 0ì´ë©´ ë¬´ì œí•œ
    schedules: [],
    phases: {
        phase1: true,
        phase2: true,
        phase3: true,
        phase4: true,
        phase5: true  // âœ… Phase 5 ì¶”ê°€!
    },
    skuDedup: true  // âœ… SKU ì¤‘ë³µ ë°©ì§€ (Shopify ê¸°ì¤€) - ê¸°ë³¸ê°’ ON
};

// ì„¤ì • ë¡œë“œ
function loadConfig() {
    try {
        if (fs.existsSync(CONFIG_FILE)) {
            const data = fs.readFileSync(CONFIG_FILE, 'utf-8');
            config = { ...config, ...JSON.parse(data) };
            console.log('âœ… ì„¤ì • ë¡œë“œ ì™„ë£Œ');
        }
    } catch (error) {
        console.error('âŒ ì„¤ì • ë¡œë“œ ì‹¤íŒ¨:', error.message);
    }
}

// ì„¤ì • ì €ìž¥
function saveConfig() {
    try {
        fs.writeFileSync(CONFIG_FILE, JSON.stringify(config, null, 2));
        console.log('âœ… ì„¤ì • ì €ìž¥ ì™„ë£Œ');
    } catch (error) {
        console.error('âŒ ì„¤ì • ì €ìž¥ ì‹¤íŒ¨:', error.message);
    }
}

loadConfig();

// ==================== URL í ê´€ë¦¬ ====================
const URL_QUEUE_FILE = path.join(__dirname, 'url-queue.json');

let urlQueue = {
    categories: [],
    products: []
};

function loadUrlQueue() {
    try {
        if (fs.existsSync(URL_QUEUE_FILE)) {
            const data = fs.readFileSync(URL_QUEUE_FILE, 'utf-8');
            urlQueue = JSON.parse(data);
            console.log('âœ… URL í ë¡œë“œ ì™„ë£Œ');
        }
    } catch (error) {
        console.error('âŒ URL í ë¡œë“œ ì‹¤íŒ¨:', error.message);
    }
}

function saveUrlQueue() {
    try {
        fs.writeFileSync(URL_QUEUE_FILE, JSON.stringify(urlQueue, null, 2));
    } catch (error) {
        console.error('âŒ URL í ì €ìž¥ ì‹¤íŒ¨:', error.message);
    }
}

loadUrlQueue();

// ==================== ë¡œê·¸ ê´€ë¦¬ (âœ… ì‹œê°„ í¬ë§· ì¶”ê°€) ====================
const logs = [];
const MAX_LOGS = 3000;

// âœ… ì‹œê°„ í¬ë§· í•¨ìˆ˜
function formatTime(date) {
    const d = new Date(date);
    const hours = String(d.getHours()).padStart(2, '0');
    const minutes = String(d.getMinutes()).padStart(2, '0');
    const seconds = String(d.getSeconds()).padStart(2, '0');
    return `${hours}:${minutes}:${seconds}`;
}

function addLog(type, message, phase = null) {
    const now = new Date();
    const log = {
        id: uuidv4(),
        timestamp: now.toISOString(),
        timeFormatted: formatTime(now),  // âœ… í¬ë§·ëœ ì‹œê°„ ì¶”ê°€
        type, // info, success, error, warning
        message,
        phase
    };
    
    logs.push(log);
    if (logs.length > MAX_LOGS) {
        logs.shift();
    }
    
    io.emit('log', log);
    return log;
}

// ==================== ì‹¤í–‰ ì´ë ¥ ====================
const executionHistory = [];

function addExecutionHistory(execution) {
    executionHistory.unshift(execution);
    if (executionHistory.length > 100) {
        executionHistory.pop();
    }
}

// ==================== ì´ë¯¸ì§€ URL í—¬í¼ í•¨ìˆ˜ ====================
function getImageUrl(imageData) {
    if (!imageData) return null;
    
    const img = Array.isArray(imageData) ? imageData[0] : imageData;
    if (!img) return null;
    
    if (img.url && img.url.startsWith('http')) {
        return img.url;
    }
    
    if (img.signedPath) {
        return `${NOCODB_API_URL}/${img.signedPath}`;
    }
    
    if (img.path) {
        return `${NOCODB_API_URL}/${img.path}`;
    }
    
    if (img.url) {
        return `${NOCODB_API_URL}/${img.url}`;
    }
    
    return null;
}

// ==================== Phase ì •ì˜ ====================
const PHASES = [
    { id: 'phase0', name: 'Phase 0: URL ìˆ˜ì§‘', script: 'phase0-url-collector.js' },
    { id: 'phase1', name: 'Phase 1: ìŠ¤í¬ëž˜í•‘', script: 'phase1-main-gallery.js' },
    { id: 'phase2', name: 'Phase 2: ë°°ê²½ ì œê±°', script: 'phase2-ai-generate.js' },
    { id: 'phase3', name: 'Phase 3: AI í¬ë¡­', script: 'phase3-multi-3products.js' },
    { id: 'phase4', name: 'Phase 4: ì´ë¯¸ì§€ ì„ ë³„', script: 'phase4-final-data.js' },
    { id: 'phase5', name: 'Phase 5: Shopify ì—…ë¡œë“œ', script: 'phase5-shopify-upload.js' }  // âœ… Phase 5 ì¶”ê°€!
];

// ==================== Phase 0: URL ìˆ˜ì§‘ (âœ… maxPages 0 = ë¬´ì œí•œ, âœ… í†µí•© ë¡œê·¸ ì§€ì›) ====================
// ðŸ”§ ìˆ˜ì • 1: unifiedLogPath íŒŒë¼ë¯¸í„° ì¶”ê°€
async function runPhase0(categoryUrl, maxProducts, categoryName, maxPages = 0, unifiedLogPath = null) {
    return new Promise((resolve, reject) => {
        const scriptPath = path.join(SCRIPTS_DIR, 'phase0-url-collector.js');
        
        if (!fs.existsSync(scriptPath)) {
            addLog('error', `âŒ Phase 0 ìŠ¤í¬ë¦½íŠ¸ ì—†ìŒ: ${scriptPath}`, 'phase0');
            reject(new Error('phase0-url-collector.js not found'));
            return;
        }
        
        const pagesText = maxPages === 0 ? 'ë¬´ì œí•œ' : `${maxPages}íŽ˜ì´ì§€`;
        addLog('info', `ðŸš€ Phase 0 ì‹œìž‘: ${categoryName || 'ì¹´í…Œê³ ë¦¬'} (ìµœëŒ€ ${maxProducts}ê°œ, ${pagesText})`, 'phase0');
        
        // ðŸ”§ ìˆ˜ì • 2: í†µí•© ë¡œê·¸ì— Phase 0 ì‹œìž‘ ê¸°ë¡
        if (unifiedLogPath) {
            writeUnifiedLog(unifiedLogPath, '');
            writeUnifiedLog(unifiedLogPath, `â•â•â• PHASE 0: URL ìˆ˜ì§‘ ì‹œìž‘ â•â•â•`);
            writeUnifiedLog(unifiedLogPath, `ðŸ“‚ ì¹´í…Œê³ ë¦¬: ${categoryName || 'Unknown'}`);
            writeUnifiedLog(unifiedLogPath, `ðŸ“Š ìµœëŒ€ ìˆ˜ì§‘: ${maxProducts}ê°œ, ${pagesText}`);
        }
        
        // ðŸ”§ ìˆ˜ì • 3: í™˜ê²½ë³€ìˆ˜ì— UNIFIED_LOG_PATH ì¶”ê°€
        const env = {
            ...process.env,
            CATEGORY_URL: categoryUrl,
            MAX_PRODUCTS: maxProducts.toString(),
            MAX_PAGES: maxPages.toString(),
            UNIFIED_LOG_PATH: unifiedLogPath || '',  // âœ… í†µí•© ë¡œê·¸ ê²½ë¡œ ì „ë‹¬
            SKU_DEDUP_ENABLED: (config.skuDedup !== false).toString()  // âœ… SKU ì¤‘ë³µ ë°©ì§€ ì„¤ì • ì „ë‹¬
        };
        
        const child = spawn('node', [scriptPath], {
            cwd: SCRIPTS_DIR,
            env: env
        });
        
        currentProcess = child;
        
        // ðŸ”§ ìˆ˜ì • 4: stdout í•¸ë“¤ëŸ¬ì— í†µí•© ë¡œê·¸ ê¸°ë¡ ì¶”ê°€
        child.stdout.on('data', (data) => {
            const lines = data.toString().split('\n').filter(l => l.trim());
            lines.forEach(line => {
                let logType = 'info';
                if (line.includes('âœ…') || line.includes('ì™„ë£Œ')) logType = 'success';
                if (line.includes('âŒ') || line.includes('ì‹¤íŒ¨')) logType = 'error';
                if (line.includes('âš ï¸')) logType = 'warning';
                
                addLog(logType, line, 'phase0');
            });
            io.emit('state', systemState);
        });

        child.stderr.on('data', (data) => {
            const message = data.toString().trim();
            if (message) {
                const isPlaywrightInfo = message.includes('INFO') || message.includes('PlaywrightCrawler');
                addLog(isPlaywrightInfo ? 'info' : 'error', message, 'phase0');
            }
        });
        
        child.on('close', (code) => {
            currentProcess = null;
            if (code === 0) {
                addLog('success', `âœ… Phase 0 ì™„ë£Œ: ${categoryName || 'ì¹´í…Œê³ ë¦¬'}`, 'phase0');
                // âœ… í†µí•© ë¡œê·¸ì— Phase 0 ì™„ë£Œ ê¸°ë¡
                if (unifiedLogPath) {
                    writeUnifiedLog(unifiedLogPath, `âœ… Phase 0 ì™„ë£Œ: ${categoryName || 'ì¹´í…Œê³ ë¦¬'}`);
                }
                resolve(true);
            } else {
                addLog('error', `âŒ Phase 0 ì‹¤íŒ¨ (ì½”ë“œ: ${code})`, 'phase0');
                if (unifiedLogPath) {
                    writeUnifiedLog(unifiedLogPath, `âŒ Phase 0 ì‹¤íŒ¨ (ì½”ë“œ: ${code})`);
                }
                reject(new Error(`Phase 0 failed with code ${code}`));
            }
        });
        
        child.on('error', (error) => {
            currentProcess = null;
            addLog('error', `âŒ Phase 0 ì˜¤ë¥˜: ${error.message}`, 'phase0');
            reject(error);
        });
    });
}

// URL í ì „ì²´ ì²˜ë¦¬ (âœ… maxPages ì§€ì›, âœ… í†µí•© ë¡œê·¸ ì§€ì›)
// ðŸ”§ ìˆ˜ì • 5: unifiedLogPath íŒŒë¼ë¯¸í„° ì¶”ê°€
async function processUrlQueue(unifiedLogPath = null) {
    if (systemState.status === 'running') {
        throw new Error('ì´ë¯¸ ì‹¤í–‰ ì¤‘ìž…ë‹ˆë‹¤');
    }
    
    const pendingCategories = urlQueue.categories.filter(c => c.status === 'pending');
    
    if (pendingCategories.length === 0) {
        throw new Error('ì²˜ë¦¬í•  ì¹´í…Œê³ ë¦¬ê°€ ì—†ìŠµë‹ˆë‹¤');
    }
    
    systemState.status = 'running';
    systemState.currentPhase = 'phase0';
    io.emit('state', systemState);
    
    addLog('info', `ðŸ“¥ URL í ì²˜ë¦¬ ì‹œìž‘: ${pendingCategories.length}ê°œ ì¹´í…Œê³ ë¦¬`);
    
    // âœ… í†µí•© ë¡œê·¸ì— í ì²˜ë¦¬ ì‹œìž‘ ê¸°ë¡
    if (unifiedLogPath) {
        writeUnifiedLog(unifiedLogPath, `ðŸ“¥ URL í ì²˜ë¦¬ ì‹œìž‘: ${pendingCategories.length}ê°œ ì¹´í…Œê³ ë¦¬`);
    }
    
    let totalCollected = 0;
    
    for (const category of pendingCategories) {
        try {
            category.status = 'processing';
            saveUrlQueue();
            io.emit('urlQueue', urlQueue);
            
            // âœ… maxPages ì „ë‹¬ (ì—†ìœ¼ë©´ 0 = ë¬´ì œí•œ)
            const maxPages = category.maxPages !== undefined ? category.maxPages : 0;
            // ðŸ”§ ìˆ˜ì • 6: runPhase0 í˜¸ì¶œ ì‹œ unifiedLogPath ì „ë‹¬
            await runPhase0(category.url, category.maxProducts, category.name, maxPages, unifiedLogPath);
            
            category.status = 'completed';
            category.completedAt = new Date().toISOString();
            totalCollected += category.maxProducts;
            
            saveUrlQueue();
            io.emit('urlQueue', urlQueue);
            
            await new Promise(resolve => setTimeout(resolve, 3000));
            
        } catch (error) {
            category.status = 'error';
            category.error = error.message;
            saveUrlQueue();
            io.emit('urlQueue', urlQueue);
            
            addLog('error', `âŒ ì¹´í…Œê³ ë¦¬ ì²˜ë¦¬ ì‹¤íŒ¨: ${category.name} - ${error.message}`);
        }
    }
    
    systemState.status = 'idle';
    systemState.currentPhase = null;
    io.emit('state', systemState);
    
    addLog('success', `ðŸŽ‰ URL í ì²˜ë¦¬ ì™„ë£Œ! ì•½ ${totalCollected}ê°œ ì œí’ˆ ìˆ˜ì§‘ë¨`);
    
    // âœ… í†µí•© ë¡œê·¸ì— í ì²˜ë¦¬ ì™„ë£Œ ê¸°ë¡
    if (unifiedLogPath) {
        writeUnifiedLog(unifiedLogPath, `ðŸŽ‰ URL í ì²˜ë¦¬ ì™„ë£Œ! ì•½ ${totalCollected}ê°œ ì œí’ˆ ìˆ˜ì§‘ë¨`);
    }
    
    return { success: true, totalCollected };
}

// ==================== í†µí•© ë¡œê·¸ ì‹œìŠ¤í…œ ====================
function getSydneyTimeForFile() {
    const now = new Date();
    const sydneyDate = new Date(now.toLocaleString('en-US', { timeZone: 'Australia/Sydney' }));
    const year = sydneyDate.getFullYear();
    const month = String(sydneyDate.getMonth() + 1).padStart(2, '0');
    const day = String(sydneyDate.getDate()).padStart(2, '0');
    const hour = String(sydneyDate.getHours()).padStart(2, '0');
    const min = String(sydneyDate.getMinutes()).padStart(2, '0');
    const sec = String(sydneyDate.getSeconds()).padStart(2, '0');
    return `${year}${month}${day}_${hour}${min}${sec}`;
}

function createUnifiedLogPath() {
    const logsDir = path.join(SCRIPTS_DIR, 'logs');
    if (!fs.existsSync(logsDir)) {
        fs.mkdirSync(logsDir, { recursive: true });
    }
    const filename = `pipeline_${getSydneyTimeForFile()}.log`;
    return path.join(logsDir, filename);
}

function writeUnifiedLog(logPath, message) {
    if (!logPath) return;
    const timestamp = new Date().toLocaleString('en-AU', {
        timeZone: 'Australia/Sydney',
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        hour12: false
    });
    fs.appendFileSync(logPath, `[${timestamp}] ${message}\n`);
}

// ==================== íŒŒì´í”„ë¼ì¸ ì‹¤í–‰ ====================
// âœ… ìˆ˜ì •: categoryUrl ì˜µì…˜ ì¶”ê°€
async function runPhase(phase, productLimit, categoryUrl = null, maxProducts = null, maxPages = null, unifiedLogPath = null) {
    return new Promise((resolve, reject) => {
        const scriptPath = path.join(SCRIPTS_DIR, phase.script);
        
        if (!fs.existsSync(scriptPath)) {
            addLog('error', `âŒ ìŠ¤í¬ë¦½íŠ¸ íŒŒì¼ ì—†ìŒ: ${scriptPath}`, phase.id);
            reject(new Error(`Script not found: ${scriptPath}`));
            return;
        }
        
        addLog('info', `ðŸš€ ${phase.name} ì‹œìž‘ (${productLimit}ê°œ ì œí’ˆ)`, phase.id);
        
        // âœ… í™˜ê²½ë³€ìˆ˜ ì„¤ì • - categoryUrlì´ ìžˆìœ¼ë©´ ì¶”ê°€
        const env = {
            ...process.env,
            PRODUCT_LIMIT: productLimit.toString(),
            MAX_VOLUME_LIMIT: (config.maxVolumeLimit || 0).toString(),  // âœ… v2.9: ìš©ëŸ‰ ì œí•œ ì „ë‹¬
            SKU_DEDUP_ENABLED: (config.skuDedup !== false).toString()  // âœ… SKU ì¤‘ë³µ ë°©ì§€ ì„¤ì • ì „ë‹¬
        };

        // âœ… í†µí•© ë¡œê·¸ ê²½ë¡œ ì „ë‹¬
        if (unifiedLogPath) {
            env.UNIFIED_LOG_PATH = unifiedLogPath;
        }

        // âœ… Phase 0ì¸ ê²½ìš° URL ê´€ë ¨ í™˜ê²½ë³€ìˆ˜ ì¶”ê°€
        if (phase.id === 'phase0' && categoryUrl) {
            env.CATEGORY_URL = categoryUrl;
            env.MAX_PRODUCTS = (maxProducts || productLimit).toString();
            env.MAX_PAGES = (maxPages || 0).toString();
            addLog('info', `ðŸ“‚ URL: ${categoryUrl.substring(0, 60)}...`, phase.id);
        }
        
        const child = spawn('node', [scriptPath], {
            cwd: SCRIPTS_DIR,
            env: env
        });
        
        currentProcess = child;
        
        child.stdout.on('data', (data) => {
            const lines = data.toString().split('\n').filter(l => l.trim());
            
            lines.forEach(line => {
                const productMatch = line.match(/\[(\d+)\/(\d+)\]/);
                if (productMatch) {
                    systemState.currentProduct = parseInt(productMatch[1]);
                    systemState.totalProducts = parseInt(productMatch[2]);
                    io.emit('progress', {
                        current: systemState.currentProduct,
                        total: systemState.totalProducts,
                        phase: phase.id
                    });
                }
                
                if (line.includes('Gemini') || line.includes('API')) {
                    systemState.stats.apiCalls++;
                    systemState.stats.estimatedCost = systemState.stats.apiCalls * 0.0001;
                }
                
                if (line.includes('âœ…') || line.includes('ì„±ê³µ')) {
                    systemState.stats.successCount++;
                }
                if (line.includes('âŒ') || line.includes('ì‹¤íŒ¨')) {
                    systemState.stats.failedCount++;
                }
                
                let logType = 'info';
                if (line.includes('âœ…') || line.includes('ì™„ë£Œ')) logType = 'success';
                if (line.includes('âŒ') || line.includes('ì‹¤íŒ¨') || line.includes('ì˜¤ë¥˜')) logType = 'error';
                if (line.includes('âš ï¸') || line.includes('ê²½ê³ ')) logType = 'warning';
                
                addLog(logType, line, phase.id);
            });
            
            io.emit('state', systemState);
        });
        
        child.stderr.on('data', (data) => {
            const message = data.toString().trim();
            if (message) {
                const isPlaywrightInfo = message.includes('INFO') || message.includes('PlaywrightCrawler');
                addLog(isPlaywrightInfo ? 'info' : 'error', message, phase.id);
                if (!isPlaywrightInfo) {
                    systemState.errors.push({
                        phase: phase.id,
                        message: message,
                        timestamp: new Date().toISOString()
                    });
                }
            }
        });
        
        child.on('close', (code) => {
            currentProcess = null;
            
            if (code === 0) {
                addLog('success', `âœ… ${phase.name} ì™„ë£Œ`, phase.id);
                resolve(true);
            } else {
                addLog('error', `âŒ ${phase.name} ì‹¤íŒ¨ (ì½”ë“œ: ${code})`, phase.id);
                reject(new Error(`Phase ${phase.id} failed with code ${code}`));
            }
        });
        
        child.on('error', (error) => {
            currentProcess = null;
            addLog('error', `âŒ ${phase.name} ì˜¤ë¥˜: ${error.message}`, phase.id);
            reject(error);
        });
    });
}

// âœ… ìˆ˜ì •: categoryUrl ì˜µì…˜ ì¶”ê°€ + í†µí•© ë¡œê·¸ ì§€ì›
// ðŸ”§ ìˆ˜ì • 7: existingLogPath ì˜µì…˜ ì¶”ê°€
async function runPipeline(options = {}) {
    const {
        productLimit = config.productLimit,
        phases = config.phases,
        categoryUrl = null,    // âœ… NEW
        maxProducts = null,    // âœ… NEW
        maxPages = null,       // âœ… NEW
        existingLogPath = null // ðŸ”§ NEW: ê¸°ì¡´ í†µí•© ë¡œê·¸ ê²½ë¡œ (process-fullì—ì„œ ì „ë‹¬)
    } = options;

    const executionId = uuidv4();
    const startTime = new Date();

    // ðŸ”§ ìˆ˜ì • 7: ê¸°ì¡´ ë¡œê·¸ ê²½ë¡œê°€ ìžˆìœ¼ë©´ ì‚¬ìš©, ì—†ìœ¼ë©´ ìƒˆë¡œ ìƒì„±
    const unifiedLogPath = existingLogPath || createUnifiedLogPath();
    
    // ìƒˆë¡œ ìƒì„±í•œ ê²½ìš°ì—ë§Œ í—¤ë” ê¸°ë¡ (ê¸°ì¡´ ê²½ë¡œë©´ ì´ë¯¸ Phase 0ì—ì„œ ê¸°ë¡ë¨)
    if (!existingLogPath) {
        writeUnifiedLog(unifiedLogPath, 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
        writeUnifiedLog(unifiedLogPath, 'ðŸŽ¬ íŒŒì´í”„ë¼ì¸ ì‹¤í–‰ ì‹œìž‘');
        writeUnifiedLog(unifiedLogPath, `ðŸ“‹ ì œí’ˆ ìˆ˜: ${productLimit}ê°œ`);
        writeUnifiedLog(unifiedLogPath, `ðŸ“ í†µí•© ë¡œê·¸: ${path.basename(unifiedLogPath)}`);
        writeUnifiedLog(unifiedLogPath, 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    }

    systemState = {
        status: 'running',
        currentPhase: null,
        currentProduct: 0,
        totalProducts: productLimit,
        startTime: startTime.toISOString(),
        pausedAt: null,
        errors: [],
        stats: {
            totalProcessed: 0,
            successCount: 0,
            failedCount: 0,
            apiCalls: 0,
            estimatedCost: 0
        },
        unifiedLogPath: unifiedLogPath  // âœ… í†µí•© ë¡œê·¸ ê²½ë¡œ ì €ìž¥
    };

    io.emit('state', systemState);
    addLog('info', `ðŸŽ¬ íŒŒì´í”„ë¼ì¸ ì‹œìž‘ (${productLimit}ê°œ ì œí’ˆ)`);
    
    // âœ… NEW: categoryUrlì´ ìžˆìœ¼ë©´ Phase 0 ë¨¼ì € ì‹¤í–‰
    if (categoryUrl && phases.phase0) {
        try {
            systemState.currentPhase = 'phase0';
            io.emit('state', systemState);
            
            addLog('info', `ðŸ“‚ ìƒˆ URLì—ì„œ ì œí’ˆ ìˆ˜ì§‘: ${categoryUrl.substring(0, 60)}...`);
            await runPhase0(categoryUrl, maxProducts || productLimit, 'URL ìˆ˜ì§‘', maxPages || 0);
            
            await new Promise(resolve => setTimeout(resolve, 2000));
        } catch (error) {
            addLog('error', `âŒ Phase 0 ì‹¤íŒ¨: ${error.message}`);
            
            // Phase 0 ì‹¤íŒ¨ ì‹œ ì „ì²´ íŒŒì´í”„ë¼ì¸ ì¤‘ë‹¨ ì—¬ë¶€ ê²°ì •
            systemState.status = 'error';
            io.emit('state', systemState);
            return { success: false, error: error.message };
        }
    }
    
    // Phase 1~5ë§Œ í•„í„°ë§ (Phase 0 ì´ë¯¸ ì²˜ë¦¬ë¨ ë˜ëŠ” ì œì™¸)
    const pipelinePhases = PHASES.filter(p => p.id !== 'phase0');
    const enabledPhases = pipelinePhases.filter(p => phases[p.id]);
    
    try {
        for (const phase of enabledPhases) {
            if (isPaused) {
                systemState.status = 'paused';
                systemState.pausedAt = new Date().toISOString();
                io.emit('state', systemState);
                addLog('warning', 'â¸ï¸ íŒŒì´í”„ë¼ì¸ ì¼ì‹œì •ì§€ë¨');
                
                await new Promise((resolve) => {
                    const checkPause = setInterval(() => {
                        if (!isPaused) {
                            clearInterval(checkPause);
                            resolve();
                        }
                    }, 1000);
                });
                
                systemState.status = 'running';
                systemState.pausedAt = null;
                io.emit('state', systemState);
                addLog('info', 'â–¶ï¸ íŒŒì´í”„ë¼ì¸ ìž¬ê°œë¨');
            }
            
            systemState.currentPhase = phase.id;
            io.emit('state', systemState);

            // âœ… í†µí•© ë¡œê·¸ì— Phase ì‹œìž‘ ê¸°ë¡
            writeUnifiedLog(unifiedLogPath, '');
            writeUnifiedLog(unifiedLogPath, `â•â•â• ${phase.name.toUpperCase()} ì‹œìž‘ â•â•â•`);

            await runPhase(phase, productLimit, null, null, null, unifiedLogPath);

            await new Promise(resolve => setTimeout(resolve, 2000));
        }
        
        const endTime = new Date();
        const duration = Math.round((endTime - startTime) / 1000);
        
        systemState.status = 'idle';
        systemState.currentPhase = null;
        systemState.stats.totalProcessed = productLimit;
        io.emit('state', systemState);
        
        addLog('success', `ðŸŽ‰ íŒŒì´í”„ë¼ì¸ ì™„ë£Œ! (ì†Œìš” ì‹œê°„: ${Math.floor(duration / 60)}ë¶„ ${duration % 60}ì´ˆ)`);

        // âœ… í†µí•© ë¡œê·¸ì— ì™„ë£Œ ê¸°ë¡
        writeUnifiedLog(unifiedLogPath, '');
        writeUnifiedLog(unifiedLogPath, 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
        writeUnifiedLog(unifiedLogPath, 'ðŸŽ‰ íŒŒì´í”„ë¼ì¸ ì™„ë£Œ!');
        writeUnifiedLog(unifiedLogPath, `â±ï¸  ì†Œìš” ì‹œê°„: ${Math.floor(duration / 60)}ë¶„ ${duration % 60}ì´ˆ`);
        writeUnifiedLog(unifiedLogPath, `âœ… ì„±ê³µ: ${systemState.stats.successCount}ê°œ`);
        writeUnifiedLog(unifiedLogPath, `âŒ ì‹¤íŒ¨: ${systemState.stats.failedCount}ê°œ`);
        writeUnifiedLog(unifiedLogPath, 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');

        addExecutionHistory({
            id: executionId,
            startTime: startTime.toISOString(),
            endTime: endTime.toISOString(),
            duration: duration,
            productLimit: productLimit,
            phases: enabledPhases.map(p => p.id),
            stats: { ...systemState.stats },
            errors: [...systemState.errors],
            status: 'completed'
        });
        
        return { success: true, duration, stats: systemState.stats };
        
    } catch (error) {
        const endTime = new Date();
        const duration = Math.round((endTime - startTime) / 1000);
        
        systemState.status = 'error';
        io.emit('state', systemState);
        
        addLog('error', `âŒ íŒŒì´í”„ë¼ì¸ ì‹¤íŒ¨: ${error.message}`);
        
        addExecutionHistory({
            id: executionId,
            startTime: startTime.toISOString(),
            endTime: endTime.toISOString(),
            duration: duration,
            productLimit: productLimit,
            phases: enabledPhases.map(p => p.id),
            stats: { ...systemState.stats },
            errors: [...systemState.errors],
            status: 'failed',
            errorMessage: error.message
        });
        
        return { success: false, error: error.message, stats: systemState.stats };
    }
}

// ==================== ìŠ¤ì¼€ì¤„ë§ ====================
function setupSchedules() {
    scheduledJobs.forEach(job => job.stop());
    scheduledJobs = [];
    
    config.schedules.forEach(schedule => {
        if (!schedule.enabled) return;
        
        try {
            const job = cron.schedule(schedule.cron, async () => {
                addLog('info', `â° ìŠ¤ì¼€ì¤„ ì‹¤í–‰: ${schedule.name}`);
                await runPipeline({
                    productLimit: schedule.productLimit,
                    phases: schedule.phases || config.phases
                });
            });
            
            scheduledJobs.push(job);
            addLog('info', `ðŸ“… ìŠ¤ì¼€ì¤„ ë“±ë¡: ${schedule.name} (${schedule.cron})`);
        } catch (error) {
            addLog('error', `âŒ ìŠ¤ì¼€ì¤„ ë“±ë¡ ì‹¤íŒ¨: ${schedule.name} - ${error.message}`);
        }
    });
}

setupSchedules();

// ==================== NocoDB API ====================
async function getProductStats() {
    try {
        const oliveyoungResponse = await axios.get(
            `${NOCODB_API_URL}/api/v2/tables/${OLIVEYOUNG_TABLE_ID}/records`,
            {
                headers: { 'xc-token': NOCODB_API_TOKEN },
                params: { limit: 1, offset: 0 }
            }
        );
        
        const shopifyResponse = await axios.get(
            `${NOCODB_API_URL}/api/v2/tables/${SHOPIFY_TABLE_ID}/records`,
            {
                headers: { 'xc-token': NOCODB_API_TOKEN },
                params: { limit: 1, offset: 0 }
            }
        );
        
        const completedResponse = await axios.get(
            `${NOCODB_API_URL}/api/v2/tables/${SHOPIFY_TABLE_ID}/records`,
            {
                headers: { 'xc-token': NOCODB_API_TOKEN },
                params: {
                    limit: 1,
                    where: '(main_image,notnull)'
                }
            }
        );
        
        return {
            totalProducts: oliveyoungResponse.data.pageInfo?.totalRows || 0,
            shopifyProducts: shopifyResponse.data.pageInfo?.totalRows || 0,
            completedProducts: completedResponse.data.pageInfo?.totalRows || 0
        };
    } catch (error) {
        console.error('âŒ í†µê³„ ì¡°íšŒ ì‹¤íŒ¨:', error.message);
        return {
            totalProducts: 0,
            shopifyProducts: 0,
            completedProducts: 0
        };
    }
}

async function getRecentProducts(limit = 10) {
    try {
        const response = await axios.get(
            `${NOCODB_API_URL}/api/v2/tables/${SHOPIFY_TABLE_ID}/records`,
            {
                headers: { 'xc-token': NOCODB_API_TOKEN },
                params: {
                    limit: limit,
                    sort: '-made_at',
                    where: '(main_image,notnull)'
                }
            }
        );
        
        return response.data.list.map(product => {
            const mainImageUrl = getImageUrl(product.main_image);
            
            return {
                id: product.Id,
                title: product.title_en || product.title_kr || `ì œí’ˆ #${product.Id}`,
                mainImage: mainImageUrl,
                galleryImages: product.gallery_images?.length || 0,
                madeAt: product.made_at,
                priceAud: product.price_aud
            };
        });
    } catch (error) {
        console.error('âŒ ìµœê·¼ ì œí’ˆ ì¡°íšŒ ì‹¤íŒ¨:', error.message);
        return [];
    }
}

async function getFailedProducts() {
    try {
        const response = await axios.get(
            `${NOCODB_API_URL}/api/v2/tables/${SHOPIFY_TABLE_ID}/records`,
            {
                headers: { 'xc-token': NOCODB_API_TOKEN },
                params: {
                    limit: 50,
                    where: '(validated_images,notnull)~and(main_image,null)'
                }
            }
        );
        
        return response.data.list.map(product => ({
            id: product.Id,
            title: product.title_en || product.title_kr || `ì œí’ˆ #${product.Id}`,
            validatedImages: product.validated_images?.length || 0
        }));
    } catch (error) {
        console.error('âŒ ì‹¤íŒ¨ ì œí’ˆ ì¡°íšŒ ì‹¤íŒ¨:', error.message);
        return [];
    }
}

// ==================== API ë¼ìš°íŠ¸ ====================

// ìƒíƒœ ì¡°íšŒ
app.get('/api/state', (req, res) => {
    res.json(systemState);
});

// ì„¤ì • ì¡°íšŒ
app.get('/api/config', (req, res) => {
    res.json(config);
});

// ì„¤ì • ì €ìž¥
app.post('/api/config', (req, res) => {
    config = { ...config, ...req.body };
    saveConfig();
    setupSchedules();
    res.json({ success: true, config });
});

// âœ… ìˆ˜ì •: íŒŒì´í”„ë¼ì¸ ì‹¤í–‰ - categoryUrl íŒŒë¼ë¯¸í„° ì¶”ê°€
app.post('/api/pipeline/start', async (req, res) => {
    if (systemState.status === 'running') {
        return res.status(400).json({ error: 'ì´ë¯¸ ì‹¤í–‰ ì¤‘ìž…ë‹ˆë‹¤' });
    }
    
    const { productLimit, phases, categoryUrl, maxProducts, maxPages } = req.body;
    
    // âœ… URL ìœ íš¨ì„± ê²€ì‚¬
    if (categoryUrl && !categoryUrl.includes('oliveyoung.co.kr')) {
        return res.status(400).json({ error: 'ì˜¬ë¦¬ë¸Œì˜ URLì´ ì•„ë‹™ë‹ˆë‹¤' });
    }
    
    res.json({ success: true, message: 'íŒŒì´í”„ë¼ì¸ ì‹œìž‘ë¨' });
    
    runPipeline({
        productLimit: productLimit || config.productLimit,
        phases: phases || config.phases,
        categoryUrl: categoryUrl || null,      // âœ… NEW
        maxProducts: maxProducts || null,      // âœ… NEW
        maxPages: maxPages || null             // âœ… NEW
    });
});

// íŒŒì´í”„ë¼ì¸ ì¼ì‹œì •ì§€
app.post('/api/pipeline/pause', (req, res) => {
    if (systemState.status !== 'running') {
        return res.status(400).json({ error: 'ì‹¤í–‰ ì¤‘ì´ ì•„ë‹™ë‹ˆë‹¤' });
    }
    
    isPaused = true;
    res.json({ success: true, message: 'ì¼ì‹œì •ì§€ ìš”ì²­ë¨' });
});

// íŒŒì´í”„ë¼ì¸ ìž¬ê°œ
app.post('/api/pipeline/resume', (req, res) => {
    if (systemState.status !== 'paused') {
        return res.status(400).json({ error: 'ì¼ì‹œì •ì§€ ìƒíƒœê°€ ì•„ë‹™ë‹ˆë‹¤' });
    }
    
    isPaused = false;
    res.json({ success: true, message: 'ìž¬ê°œë¨' });
});

// íŒŒì´í”„ë¼ì¸ ì¤‘ì§€
app.post('/api/pipeline/stop', (req, res) => {
    if (currentProcess) {
        currentProcess.kill('SIGTERM');
        currentProcess = null;
    }
    
    isPaused = false;
    systemState.status = 'idle';
    systemState.currentPhase = null;
    io.emit('state', systemState);
    
    addLog('warning', 'ðŸ›‘ íŒŒì´í”„ë¼ì¸ ê°•ì œ ì¤‘ì§€ë¨');
    
    res.json({ success: true, message: 'ì¤‘ì§€ë¨' });
});

// âœ… ìˆ˜ì •: ë‹¨ì¼ Phase ì‹¤í–‰ - categoryUrl íŒŒë¼ë¯¸í„° ì¶”ê°€
app.post('/api/pipeline/run-phase', async (req, res) => {
    if (systemState.status === 'running') {
        return res.status(400).json({ error: 'ì´ë¯¸ ì‹¤í–‰ ì¤‘ìž…ë‹ˆë‹¤' });
    }
    
    const { phaseId, productLimit, categoryUrl, maxProducts, maxPages } = req.body;
    const phase = PHASES.find(p => p.id === phaseId);
    
    if (!phase) {
        return res.status(400).json({ error: 'ìœ íš¨í•˜ì§€ ì•Šì€ Phase' });
    }
    
    // âœ… Phase 0ì¸ ê²½ìš° URL í•„ìˆ˜ ì²´í¬
    if (phaseId === 'phase0') {
        if (!categoryUrl) {
            return res.status(400).json({ error: 'Phase 0 ì‹¤í–‰ì—ëŠ” ì¹´í…Œê³ ë¦¬ URLì´ í•„ìš”í•©ë‹ˆë‹¤' });
        }
        if (!categoryUrl.includes('oliveyoung.co.kr')) {
            return res.status(400).json({ error: 'ì˜¬ë¦¬ë¸Œì˜ URLì´ ì•„ë‹™ë‹ˆë‹¤' });
        }
    }
    
    res.json({ success: true, message: `${phase.name} ì‹œìž‘ë¨` });
    
    systemState.status = 'running';
    systemState.currentPhase = phaseId;
    io.emit('state', systemState);
    
    try {
        // âœ… Phase 0ì¸ ê²½ìš° runPhase0 ì‚¬ìš©, ê·¸ ì™¸ì—ëŠ” runPhase ì‚¬ìš©
        if (phaseId === 'phase0') {
            await runPhase0(categoryUrl, maxProducts || productLimit || config.productLimit, 'URL ìˆ˜ì§‘', maxPages || 0);
        } else {
            await runPhase(phase, productLimit || config.productLimit);
        }
        
        systemState.status = 'idle';
        systemState.currentPhase = null;
        io.emit('state', systemState);
    } catch (error) {
        systemState.status = 'error';
        io.emit('state', systemState);
    }
});

// ë¡œê·¸ ì¡°íšŒ
app.get('/api/logs', (req, res) => {
    const { limit = 100, phase, type } = req.query;
    
    let filteredLogs = [...logs];
    
    if (phase) {
        filteredLogs = filteredLogs.filter(l => l.phase === phase);
    }
    
    if (type) {
        filteredLogs = filteredLogs.filter(l => l.type === type);
    }
    
    res.json(filteredLogs.slice(-parseInt(limit)));
});

// ì‹¤í–‰ ì´ë ¥
app.get('/api/history', (req, res) => {
    res.json(executionHistory);
});

// í†µê³„
app.get('/api/stats', async (req, res) => {
    const dbStats = await getProductStats();
    
    res.json({
        database: dbStats,
        current: systemState.stats,
        history: {
            totalExecutions: executionHistory.length,
            successfulExecutions: executionHistory.filter(e => e.status === 'completed').length,
            failedExecutions: executionHistory.filter(e => e.status === 'failed').length,
            totalApiCalls: executionHistory.reduce((sum, e) => sum + (e.stats?.apiCalls || 0), 0),
            totalCost: executionHistory.reduce((sum, e) => sum + (e.stats?.estimatedCost || 0), 0)
        }
    });
});

// ìµœê·¼ ì²˜ë¦¬ëœ ì œí’ˆ
app.get('/api/products/recent', async (req, res) => {
    const { limit = 10 } = req.query;
    const products = await getRecentProducts(parseInt(limit));
    res.json(products);
});

// ì‹¤íŒ¨í•œ ì œí’ˆ
app.get('/api/products/failed', async (req, res) => {
    const products = await getFailedProducts();
    res.json(products);
});

// ì‹¤íŒ¨ ì œí’ˆ ìž¬ì²˜ë¦¬
app.post('/api/products/retry', async (req, res) => {
    const { productIds } = req.body;
    
    if (!productIds || productIds.length === 0) {
        return res.status(400).json({ error: 'ì œí’ˆ IDê°€ í•„ìš”í•©ë‹ˆë‹¤' });
    }
    
    res.json({ success: true, message: `${productIds.length}ê°œ ì œí’ˆ ìž¬ì²˜ë¦¬ ì˜ˆì •` });
});

// ìŠ¤ì¼€ì¤„ ëª©ë¡
app.get('/api/schedules', (req, res) => {
    res.json(config.schedules || []);
});

// ìŠ¤ì¼€ì¤„ ì¶”ê°€
app.post('/api/schedules', (req, res) => {
    const schedule = {
        id: uuidv4(),
        ...req.body,
        createdAt: new Date().toISOString()
    };
    
    config.schedules = config.schedules || [];
    config.schedules.push(schedule);
    saveConfig();
    setupSchedules();
    
    res.json({ success: true, schedule });
});

// ìŠ¤ì¼€ì¤„ ì‚­ì œ
app.delete('/api/schedules/:id', (req, res) => {
    const { id } = req.params;
    config.schedules = config.schedules.filter(s => s.id !== id);
    saveConfig();
    setupSchedules();
    
    res.json({ success: true });
});

// ìŠ¤ì¼€ì¤„ í† ê¸€
app.patch('/api/schedules/:id/toggle', (req, res) => {
    const { id } = req.params;
    const schedule = config.schedules.find(s => s.id === id);
    
    if (schedule) {
        schedule.enabled = !schedule.enabled;
        saveConfig();
        setupSchedules();
        res.json({ success: true, enabled: schedule.enabled });
    } else {
        res.status(404).json({ error: 'ìŠ¤ì¼€ì¤„ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤' });
    }
});

// Phase ëª©ë¡
app.get('/api/phases', (req, res) => {
    res.json(PHASES);
});

// ë””ë²„ê·¸ìš©: ì´ë¯¸ì§€ URL í™•ì¸
app.get('/api/debug/image/:id', async (req, res) => {
    try {
        const { id } = req.params;
        const response = await axios.get(
            `${NOCODB_API_URL}/api/v2/tables/${SHOPIFY_TABLE_ID}/records`,
            {
                headers: { 'xc-token': NOCODB_API_TOKEN },
                params: {
                    where: `(Id,eq,${id})`
                }
            }
        );
        
        if (response.data.list.length > 0) {
            const product = response.data.list[0];
            res.json({
                id: product.Id,
                main_image_raw: product.main_image,
                main_image_url: getImageUrl(product.main_image),
                gallery_images_raw: product.gallery_images
            });
        } else {
            res.status(404).json({ error: 'ì œí’ˆ ì—†ìŒ' });
        }
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// ==================== URL í API ====================

// URL í ì¡°íšŒ
app.get('/api/url-queue', (req, res) => {
    res.json(urlQueue);
});

// ì¹´í…Œê³ ë¦¬ ì¶”ê°€ (âœ… maxPages: 0 = ë¬´ì œí•œ, null/undefined = ë¬´ì œí•œ)
app.post('/api/url-queue/category', (req, res) => {
    const { url, name, maxProducts = 100, maxPages = 0, limitPages = false } = req.body;
    
    if (!url) {
        return res.status(400).json({ error: 'URLì´ í•„ìš”í•©ë‹ˆë‹¤' });
    }
    
    if (!url.includes('oliveyoung.co.kr')) {
        return res.status(400).json({ error: 'ì˜¬ë¦¬ë¸Œì˜ URLì´ ì•„ë‹™ë‹ˆë‹¤' });
    }
    
    // âœ… limitPagesê°€ falseë©´ maxPagesë¥¼ 0ìœ¼ë¡œ (ë¬´ì œí•œ)
    const finalMaxPages = limitPages ? (parseInt(maxPages) || 10) : 0;
    
    const category = {
        id: uuidv4(),
        url: url.trim(),
        name: name?.trim() || 'ì´ë¦„ ì—†ìŒ',
        maxProducts: parseInt(maxProducts) || 100,
        maxPages: finalMaxPages,  // âœ… 0 = ë¬´ì œí•œ
        status: 'pending',
        createdAt: new Date().toISOString()
    };
    
    urlQueue.categories.push(category);
    saveUrlQueue();
    
    io.emit('urlQueue', urlQueue);
    const pagesText = finalMaxPages === 0 ? 'ë¬´ì œí•œ' : `${finalMaxPages}íŽ˜ì´ì§€`;
    addLog('info', `ðŸ“‚ ì¹´í…Œê³ ë¦¬ ì¶”ê°€ë¨: ${category.name} (ìµœëŒ€ ${category.maxProducts}ê°œ, ${pagesText})`);
    
    res.json({ success: true, category });
});

// ì¹´í…Œê³ ë¦¬ ì‚­ì œ
app.delete('/api/url-queue/category/:id', (req, res) => {
    const { id } = req.params;
    
    const index = urlQueue.categories.findIndex(c => c.id === id);
    if (index === -1) {
        return res.status(404).json({ error: 'ì¹´í…Œê³ ë¦¬ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤' });
    }
    
    const removed = urlQueue.categories.splice(index, 1)[0];
    saveUrlQueue();
    
    io.emit('urlQueue', urlQueue);
    addLog('info', `ðŸ—‘ï¸ ì¹´í…Œê³ ë¦¬ ì‚­ì œë¨: ${removed.name}`);
    
    res.json({ success: true });
});

// ì¹´í…Œê³ ë¦¬ ìƒíƒœ ì´ˆê¸°í™”
app.patch('/api/url-queue/category/:id/reset', (req, res) => {
    const { id } = req.params;
    
    const category = urlQueue.categories.find(c => c.id === id);
    if (!category) {
        return res.status(404).json({ error: 'ì¹´í…Œê³ ë¦¬ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤' });
    }
    
    category.status = 'pending';
    delete category.completedAt;
    delete category.error;
    saveUrlQueue();
    
    io.emit('urlQueue', urlQueue);
    
    res.json({ success: true, category });
});

// ì™„ë£Œëœ í•­ëª© ì‚­ì œ
app.delete('/api/url-queue/completed', (req, res) => {
    const before = urlQueue.categories.length;
    urlQueue.categories = urlQueue.categories.filter(c => c.status !== 'completed');
    const removed = before - urlQueue.categories.length;
    
    saveUrlQueue();
    io.emit('urlQueue', urlQueue);
    
    res.json({ success: true, removed });
});

// URL í ì‹¤í–‰ (Phase 0ë§Œ)
app.post('/api/url-queue/process', async (req, res) => {
    try {
        if (systemState.status === 'running') {
            return res.status(400).json({ error: 'ì´ë¯¸ ì‹¤í–‰ ì¤‘ìž…ë‹ˆë‹¤' });
        }
        
        res.json({ success: true, message: 'URL í ì²˜ë¦¬ ì‹œìž‘ë¨' });
        
        processUrlQueue().catch(error => {
            addLog('error', `âŒ URL í ì²˜ë¦¬ ì‹¤íŒ¨: ${error.message}`);
        });
        
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// URL í + íŒŒì´í”„ë¼ì¸ í†µí•© ì‹¤í–‰
// ðŸ”§ ìˆ˜ì • 8: í†µí•© ë¡œê·¸ë¥¼ ë¨¼ì € ìƒì„±í•˜ê³  Phase 0 â†’ Phase 1~5 ëª¨ë‘ì— ì „ë‹¬
app.post('/api/url-queue/process-full', async (req, res) => {
    try {
        if (systemState.status === 'running') {
            return res.status(400).json({ error: 'ì´ë¯¸ ì‹¤í–‰ ì¤‘ìž…ë‹ˆë‹¤' });
        }
        
        const { phases = config.phases } = req.body;
        
        res.json({ success: true, message: 'URL ìˆ˜ì§‘ + íŒŒì´í”„ë¼ì¸ ì‹œìž‘ë¨' });
        
        (async () => {
            try {
                // ðŸ”§ í†µí•© ë¡œê·¸ íŒŒì¼ ë¨¼ì € ìƒì„±
                const unifiedLogPath = createUnifiedLogPath();
                
                // ðŸ”§ ì˜ˆìƒ ì´ ì œí’ˆ ìˆ˜ ê³„ì‚°
                const pendingCategories = urlQueue.categories.filter(c => c.status === 'pending');
                const expectedTotal = pendingCategories.reduce((sum, c) => sum + c.maxProducts, 0);
                
                // ðŸ”§ í†µí•© ë¡œê·¸ í—¤ë” ìž‘ì„±
                writeUnifiedLog(unifiedLogPath, 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                writeUnifiedLog(unifiedLogPath, 'ðŸŽ¬ ì „ì²´ íŒŒì´í”„ë¼ì¸ ì‹œìž‘ (Phase 0 â†’ Phase 1~5)');
                writeUnifiedLog(unifiedLogPath, `ðŸ“‹ ì˜ˆìƒ ì œí’ˆ ìˆ˜: ${expectedTotal}ê°œ`);
                writeUnifiedLog(unifiedLogPath, `ðŸ“‚ ì¹´í…Œê³ ë¦¬ ìˆ˜: ${pendingCategories.length}ê°œ`);
                writeUnifiedLog(unifiedLogPath, `ðŸ“ í†µí•© ë¡œê·¸: ${path.basename(unifiedLogPath)}`);
                writeUnifiedLog(unifiedLogPath, 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                
                // ðŸ”§ processUrlQueueì— í†µí•© ë¡œê·¸ ê²½ë¡œ ì „ë‹¬
                const queueResult = await processUrlQueue(unifiedLogPath);
                
                if (queueResult.success && queueResult.totalCollected > 0) {
                    // ðŸ”§ í†µí•© ë¡œê·¸ì— Phase 1~5 ì‹œìž‘ ê¸°ë¡
                    writeUnifiedLog(unifiedLogPath, '');
                    writeUnifiedLog(unifiedLogPath, 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                    writeUnifiedLog(unifiedLogPath, 'ðŸ”„ URL ìˆ˜ì§‘ ì™„ë£Œ, Phase 1~5 ì‹œìž‘...');
                    writeUnifiedLog(unifiedLogPath, 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                    
                    addLog('info', 'ðŸ”„ URL ìˆ˜ì§‘ ì™„ë£Œ, íŒŒì´í”„ë¼ì¸ ì‹œìž‘...');
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    
                    // ðŸ”§ runPipelineì— ê¸°ì¡´ ë¡œê·¸ ê²½ë¡œ ì „ë‹¬ (ìƒˆ ë¡œê·¸ íŒŒì¼ ë§Œë“¤ì§€ ì•ŠìŒ)
                    await runPipeline({
                        productLimit: queueResult.totalCollected,
                        phases: phases,
                        existingLogPath: unifiedLogPath  // âœ… í•µì‹¬: ê¸°ì¡´ ë¡œê·¸ ê²½ë¡œ ì „ë‹¬
                    });
                } else {
                    writeUnifiedLog(unifiedLogPath, 'âš ï¸ URL ìˆ˜ì§‘ ì‹¤íŒ¨ ë˜ëŠ” ìˆ˜ì§‘ëœ ì œí’ˆ ì—†ìŒ');
                    addLog('warning', 'âš ï¸ URL ìˆ˜ì§‘ ì‹¤íŒ¨ ë˜ëŠ” ìˆ˜ì§‘ëœ ì œí’ˆ ì—†ìŒ');
                }
            } catch (error) {
                addLog('error', `âŒ í†µí•© ì‹¤í–‰ ì‹¤íŒ¨: ${error.message}`);
            }
        })();
        
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// ê°œë³„ ì œí’ˆ URL ì¶”ê°€
app.post('/api/url-queue/product', async (req, res) => {
    const { url } = req.body;
    
    if (!url) {
        return res.status(400).json({ error: 'URLì´ í•„ìš”í•©ë‹ˆë‹¤' });
    }
    
    if (!url.includes('oliveyoung.co.kr') || !url.includes('goodsNo=')) {
        return res.status(400).json({ error: 'ì˜¬ë¦¬ë¸Œì˜ ì œí’ˆ URLì´ ì•„ë‹™ë‹ˆë‹¤' });
    }
    
    const goodsNoMatch = url.match(/goodsNo=([A-Z0-9]+)/);
    if (!goodsNoMatch) {
        return res.status(400).json({ error: 'ìœ íš¨í•˜ì§€ ì•Šì€ ì œí’ˆ URLìž…ë‹ˆë‹¤' });
    }
    
    const goodsNo = goodsNoMatch[1];
    const cleanUrl = `https://www.oliveyoung.co.kr/store/goods/getGoodsDetail.do?goodsNo=${goodsNo}`;
    
    try {
        // âœ… SKU ì¤‘ë³µ ì²´í¬
        const existingCheck = await axios.get(
            `${NOCODB_API_URL}/api/v2/tables/${OLIVEYOUNG_TABLE_ID}/records`,
            {
                headers: { 'xc-token': NOCODB_API_TOKEN },
                params: {
                    where: `(sku,eq,${goodsNo})`,
                    limit: 1
                }
            }
        );
        
        if (existingCheck.data.list.length > 0) {
            return res.status(400).json({ error: `ì´ë¯¸ ë“±ë¡ëœ SKUìž…ë‹ˆë‹¤: ${goodsNo}` });
        }
        
        const productData = {
            sku: goodsNo,
            product_url: cleanUrl,
            collected_at: new Date().toISOString()
        };
        
        const response = await axios.post(
            `${NOCODB_API_URL}/api/v2/tables/${OLIVEYOUNG_TABLE_ID}/records`,
            productData,
            {
                headers: { 
                    'xc-token': NOCODB_API_TOKEN,
                    'Content-Type': 'application/json'
                }
            }
        );
        
        addLog('success', `ðŸ“¦ ì œí’ˆ URL ì¶”ê°€ë¨: ${goodsNo}`);
        res.json({ success: true, productId: response.data.Id, sku: goodsNo });
        
    } catch (error) {
        if (error.response?.status === 422) {
            return res.status(400).json({ error: 'ì´ë¯¸ ë“±ë¡ëœ URLìž…ë‹ˆë‹¤' });
        }
        res.status(500).json({ error: error.message });
    }
});

// ì˜¬ë¦¬ë¸Œì˜ ì œí’ˆ ëª©ë¡ ì¡°íšŒ
app.get('/api/oliveyoung/products', async (req, res) => {
    try {
        const { limit = 50, offset = 0 } = req.query;
        
        const response = await axios.get(
            `${NOCODB_API_URL}/api/v2/tables/${OLIVEYOUNG_TABLE_ID}/records`,
            {
                headers: { 'xc-token': NOCODB_API_TOKEN },
                params: {
                    limit: parseInt(limit),
                    offset: parseInt(offset),
                    sort: '-collected_at'
                }
            }
        );
        
        res.json({
            list: response.data.list,
            total: response.data.pageInfo?.totalRows || 0
        });
        
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// ì˜¬ë¦¬ë¸Œì˜ ì œí’ˆ ì‚­ì œ
app.delete('/api/oliveyoung/products/:id', async (req, res) => {
    try {
        const { id } = req.params;
        
        await axios.delete(
            `${NOCODB_API_URL}/api/v2/tables/${OLIVEYOUNG_TABLE_ID}/records`,
            {
                headers: { 'xc-token': NOCODB_API_TOKEN },
                data: { Id: parseInt(id) }
            }
        );
        
        res.json({ success: true });
        
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// ==================== ë¡œê·¸ íŒŒì¼ API ====================
// ì´ ì½”ë“œë¥¼ server.jsì˜ API ë¼ìš°íŠ¸ ì„¹ì…˜ì— ì¶”ê°€í•˜ì„¸ìš”
// (// ==================== ê°•ì œ ì¢…ë£Œ API ==================== ìœ„ì— ì¶”ê°€)

const LOGS_DIR = path.join(SCRIPTS_DIR, 'logs');

// ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
function formatFileSize(bytes) {
    if (bytes < 1024) return bytes + ' B';
    if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
    return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
}

function formatDateTime(date) {
    const d = new Date(date);
    const month = String(d.getMonth() + 1).padStart(2, '0');
    const day = String(d.getDate()).padStart(2, '0');
    const hours = String(d.getHours()).padStart(2, '0');
    const minutes = String(d.getMinutes()).padStart(2, '0');
    return `${month}/${day} ${hours}:${minutes}`;
}

// ë¡œê·¸ íŒŒì¼ ëª©ë¡ ì¡°íšŒ
app.get('/api/logs/files', (req, res) => {
    try {
        if (!fs.existsSync(LOGS_DIR)) {
            return res.json({ files: {}, latestFile: null, totalFiles: 0 });
        }
        
        const allFiles = fs.readdirSync(LOGS_DIR)
            .filter(f => f.endsWith('.log'))
            .map(f => {
                const filePath = path.join(LOGS_DIR, f);
                const stats = fs.statSync(filePath);
                return {
                    name: f,
                    size: stats.size,
                    sizeFormatted: formatFileSize(stats.size),
                    modifiedAt: stats.mtime.toISOString(),
                    modifiedAtFormatted: formatDateTime(stats.mtime)
                };
            })
            .sort((a, b) => new Date(b.modifiedAt) - new Date(a.modifiedAt));
        
        // Phaseë³„ë¡œ ê·¸ë£¹í™” (+ pipeline í†µí•© ë¡œê·¸ ì¶”ê°€)
        const grouped = {
            pipeline: [],  // âœ… í†µí•© ë¡œê·¸ ê·¸ë£¹ ì¶”ê°€
            phase0: [],
            phase1: [],
            phase2: [],
            phase3: [],
            phase4: [],
            phase5: []
        };

        allFiles.forEach(file => {
            // âœ… pipeline ë¡œê·¸ ë¨¼ì € ì²´í¬
            if (file.name.startsWith('pipeline_')) {
                grouped.pipeline.push(file);
            } else {
                const match = file.name.match(/^phase(\d)/);
                if (match) {
                    const phase = `phase${match[1]}`;
                    if (grouped[phase]) {
                        grouped[phase].push(file);
                    }
                }
            }
        });
        
        res.json({
            files: grouped,
            latestFile: allFiles.length > 0 ? allFiles[0].name : null,
            totalFiles: allFiles.length
        });
        
    } catch (error) {
        console.error('ë¡œê·¸ íŒŒì¼ ëª©ë¡ ì¡°íšŒ ì‹¤íŒ¨:', error);
        res.status(500).json({ error: error.message });
    }
});

// íŠ¹ì • ë¡œê·¸ íŒŒì¼ ë‚´ìš© ì¡°íšŒ
app.get('/api/logs/file/:filename', (req, res) => {
    try {
        const { filename } = req.params;
        const { filter = 'all', lines: maxLines = 2000 } = req.query;
        
        // ë³´ì•ˆ: ê²½ë¡œ íƒìƒ‰ ë°©ì§€
        if (filename.includes('..') || filename.includes('/') || filename.includes('\\')) {
            return res.status(400).json({ error: 'ìž˜ëª»ëœ íŒŒì¼ëª…' });
        }
        
        const filePath = path.join(LOGS_DIR, filename);
        
        if (!fs.existsSync(filePath)) {
            return res.status(404).json({ error: 'íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤' });
        }
        
        const stats = fs.statSync(filePath);
        const content = fs.readFileSync(filePath, 'utf-8');
        let lines = content.split('\n').filter(l => l.trim());
        
        // í•„í„° ì ìš©
        if (filter === 'summary') {
            lines = lines.filter(l => 
                l.includes('ê²°ê³¼') || l.includes('ì™„ë£Œ') || l.includes('ì‹¤íŒ¨') ||
                l.includes('ðŸŽ‰') || l.includes('âœ…') || l.includes('âŒ') ||
                l.includes('ì„±ê³µ:') || l.includes('ì´') || l.includes('ðŸ“Š') ||
                l.includes('ì‹œìž‘') || l.includes('ì¢…ë£Œ')
            );
        } else if (filter === 'errors') {
            lines = lines.filter(l => 
                l.includes('âŒ') || l.includes('ì‹¤íŒ¨') || l.includes('ì˜¤ë¥˜') || 
                l.includes('Error') || l.includes('error') || l.includes('Exception')
            );
        }
        
        // ìµœëŒ€ ì¤„ ìˆ˜ ì œí•œ
        const limitedLines = lines.slice(-parseInt(maxLines));
        
        res.json({
            filename,
            size: stats.size,
            modifiedAt: formatDateTime(stats.mtime),
            totalLines: lines.length,
            lines: limitedLines,
            content: limitedLines.join('\n')
        });
        
    } catch (error) {
        console.error('ë¡œê·¸ íŒŒì¼ ì¡°íšŒ ì‹¤íŒ¨:', error);
        res.status(500).json({ error: error.message });
    }
});

// ì „ì²´ ë¡œê·¸ ìš”ì•½
app.get('/api/logs/summary', (req, res) => {
    try {
        if (!fs.existsSync(LOGS_DIR)) {
            return res.json({ phases: {} });
        }

        // âœ… pipeline í†µí•© ë¡œê·¸ ê·¸ë£¹ ì¶”ê°€
        const phases = ['pipeline', 'phase0', 'phase1', 'phase2', 'phase3', 'phase4', 'phase5'];
        const result = {};

        phases.forEach(phase => {
            const phaseFiles = fs.readdirSync(LOGS_DIR)
                .filter(f => f.startsWith(phase) && f.endsWith('.log'))
                .map(f => {
                    const filePath = path.join(LOGS_DIR, f);
                    const stats = fs.statSync(filePath);
                    return { name: f, mtime: stats.mtime };
                })
                .sort((a, b) => b.mtime - a.mtime);
            
            if (phaseFiles.length === 0) {
                result[phase] = {
                    latestFile: null,
                    modifiedAt: null,
                    summary: ['ë¡œê·¸ íŒŒì¼ ì—†ìŒ'],
                    hasErrors: false,
                    hasWarnings: false,
                    totalFiles: 0
                };
                return;
            }
            
            // ê°€ìž¥ ìµœê·¼ íŒŒì¼ ë¶„ì„
            const latestFile = phaseFiles[0];
            const filePath = path.join(LOGS_DIR, latestFile.name);
            const content = fs.readFileSync(filePath, 'utf-8');
            const lines = content.split('\n');
            
            // ìš”ì•½ ì¶”ì¶œ (ê²°ê³¼/ì™„ë£Œ ë¶€ë¶„)
            const summaryLines = [];
            let hasErrors = false;
            let hasWarnings = false;
            
            // ì—­ìˆœìœ¼ë¡œ ê²€ìƒ‰í•˜ì—¬ ê²°ê³¼ ë¶€ë¶„ ì°¾ê¸°
            for (let i = lines.length - 1; i >= 0 && summaryLines.length < 10; i--) {
                const line = lines[i].trim();
                if (!line) continue;
                
                // ê²°ê³¼/ì™„ë£Œ/í†µê³„ ê´€ë ¨ ì¤„ ìˆ˜ì§‘
                if (line.includes('ðŸŽ‰') || line.includes('ê²°ê³¼') || line.includes('ì™„ë£Œ') ||
                    line.includes('ì„±ê³µ:') || line.includes('ì‹¤íŒ¨:') || line.includes('ì´') ||
                    line.includes('ðŸ“Š') || line.includes('ì²˜ë¦¬') || line.includes('ìˆ˜ì§‘') ||
                    (line.includes('âœ…') && (line.includes('ê°œ') || line.includes('ì™„ë£Œ'))) ||
                    (line.includes('âŒ') && (line.includes('ê°œ') || line.includes('ì‹¤íŒ¨')))) {
                    summaryLines.unshift(line);
                }
                
                if (line.includes('âŒ') || line.includes('ì‹¤íŒ¨') || line.includes('Error')) {
                    hasErrors = true;
                }
                if (line.includes('âš ï¸') || line.includes('ê²½ê³ ') || line.includes('ìŠ¤í‚µ')) {
                    hasWarnings = true;
                }
            }
            
            result[phase] = {
                latestFile: latestFile.name,
                modifiedAt: formatDateTime(latestFile.mtime),
                summary: summaryLines.length > 0 ? summaryLines : ['ìš”ì•½ ì •ë³´ ì—†ìŒ'],
                hasErrors,
                hasWarnings,
                totalFiles: phaseFiles.length
            };
        });
        
        res.json({ phases: result });
        
    } catch (error) {
        console.error('ë¡œê·¸ ìš”ì•½ ì¡°íšŒ ì‹¤íŒ¨:', error);
        res.status(500).json({ error: error.message });
    }
});

// íŠ¹ì • Phase ìµœì‹  ë¡œê·¸ ìš”ì•½
app.get('/api/logs/summary/:phase', (req, res) => {
    try {
        const { phase } = req.params;

        // âœ… pipeline ê·¸ë£¹ ì¶”ê°€
        if (!['pipeline', 'phase0', 'phase1', 'phase2', 'phase3', 'phase4', 'phase5'].includes(phase)) {
            return res.status(400).json({ error: 'ìœ íš¨í•˜ì§€ ì•Šì€ Phase' });
        }
        
        if (!fs.existsSync(LOGS_DIR)) {
            return res.json({ summary: [], latestFile: null });
        }
        
        const phaseFiles = fs.readdirSync(LOGS_DIR)
            .filter(f => f.startsWith(phase) && f.endsWith('.log'))
            .map(f => {
                const filePath = path.join(LOGS_DIR, f);
                const stats = fs.statSync(filePath);
                return { name: f, mtime: stats.mtime };
            })
            .sort((a, b) => b.mtime - a.mtime);
        
        if (phaseFiles.length === 0) {
            return res.json({ summary: ['ë¡œê·¸ íŒŒì¼ ì—†ìŒ'], latestFile: null });
        }
        
        const latestFile = phaseFiles[0];
        const filePath = path.join(LOGS_DIR, latestFile.name);
        const content = fs.readFileSync(filePath, 'utf-8');
        const lines = content.split('\n').filter(l => l.trim());
        
        // í•µì‹¬ ìš”ì•½ë§Œ ì¶”ì¶œ
        const summaryLines = lines.filter(l => 
            l.includes('ðŸŽ‰') || l.includes('ê²°ê³¼') || l.includes('ì™„ë£Œ') ||
            l.includes('ì„±ê³µ:') || l.includes('ì‹¤íŒ¨:') || l.includes('ðŸ“Š') ||
            (l.includes('âœ…') && l.includes('ê°œ')) || (l.includes('âŒ') && l.includes('ê°œ'))
        ).slice(-15);
        
        res.json({
            phase,
            latestFile: latestFile.name,
            modifiedAt: formatDateTime(latestFile.mtime),
            summary: summaryLines,
            totalLines: lines.length,
            totalFiles: phaseFiles.length
        });
        
    } catch (error) {
        console.error('Phase ë¡œê·¸ ìš”ì•½ ì¡°íšŒ ì‹¤íŒ¨:', error);
        res.status(500).json({ error: error.message });
    }
});

// ==================== ê°•ì œ ì¢…ë£Œ API ==================== âœ… ì¶”ê°€ë¨!
app.post('/api/force-kill', async (req, res) => {
    console.log('ðŸ›‘ ê°•ì œ ì¢…ë£Œ ìš”ì²­ë¨...');
    addLog('warning', 'ðŸ”´ ê°•ì œ ì¢…ë£Œ ìš”ì²­ë¨...');
    
    const results = { message: [] };
    
    // 1. í˜„ìž¬ í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œ
    if (currentProcess) {
        try {
            currentProcess.kill('SIGKILL');
            currentProcess = null;
            results.message.push('âœ… í˜„ìž¬ í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œë¨');
        } catch (e) {
            results.message.push('âš ï¸ í˜„ìž¬ í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œ ì‹¤íŒ¨: ' + e.message);
        }
    }
    
    // 2. Phase ê´€ë ¨ node í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œ
    try {
        execSync('pkill -f "node phase" 2>/dev/null || true', { timeout: 5000 });
        results.message.push('âœ… Phase í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œë¨');
    } catch (e) {
        results.message.push('âš ï¸ Phase í”„ë¡œì„¸ìŠ¤ ì—†ê±°ë‚˜ ì¢…ë£Œ ì‹¤íŒ¨');
    }
    
    // 3. Chromium/Playwright ì¢…ë£Œ
    try {
        execSync('pkill -f chromium 2>/dev/null || true', { timeout: 5000 });
        results.message.push('âœ… Chromium í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œë¨');
    } catch (e) {
        results.message.push('âš ï¸ Chromium í”„ë¡œì„¸ìŠ¤ ì—†ê±°ë‚˜ ì¢…ë£Œ ì‹¤íŒ¨');
    }
    
    // 4. ìƒíƒœ ì´ˆê¸°í™”
    isPaused = false;
    systemState.status = 'idle';
    systemState.currentPhase = null;
    io.emit('state', systemState);
    
    addLog('success', 'ðŸ›‘ ê°•ì œ ì¢…ë£Œ ì™„ë£Œ!');
    console.log('ðŸ›‘ ê°•ì œ ì¢…ë£Œ ì™„ë£Œ:', results.message.join(', '));
    
    res.json({ success: true, message: results.message.join('\n') });
});

// ==================== SKU ì¤‘ë³µ ë°©ì§€ ì„¤ì • API ====================
app.get('/api/settings/sku-dedup', (req, res) => {
    res.json({ enabled: config.skuDedup !== false });
});

app.post('/api/settings/sku-dedup', (req, res) => {
    const { enabled } = req.body;
    config.skuDedup = enabled !== false;
    saveConfig();
    addLog('info', `ðŸ”„ SKU ì¤‘ë³µ ë°©ì§€: ${config.skuDedup ? 'ON' : 'OFF'}`);
    res.json({ success: true, enabled: config.skuDedup });
});

// ==================== Shopify SKU ëª©ë¡ API ====================
app.get('/api/shopify-skus', async (req, res) => {
    if (!SHOPIFY_ACCESS_TOKEN) {
        return res.status(400).json({ error: 'Shopify Access Tokenì´ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.' });
    }
    try {
        const skus = [];
        let nextPageUrl = `https://${SHOPIFY_STORE_URL}/admin/api/${SHOPIFY_API_VERSION}/products.json?limit=250&fields=id,variants`;
        while (nextPageUrl) {
            const response = await axios.get(nextPageUrl, {
                headers: { 'X-Shopify-Access-Token': SHOPIFY_ACCESS_TOKEN },
                timeout: 30000
            });
            for (const product of (response.data.products || [])) {
                for (const variant of (product.variants || [])) {
                    if (variant.sku) skus.push(variant.sku);
                }
            }
            // Link í—¤ë” íŽ˜ì´ì§€ë„¤ì´ì…˜
            nextPageUrl = null;
            const linkHeader = response.headers['link'];
            if (linkHeader) {
                const nextMatch = linkHeader.match(/<([^>]+)>;\s*rel="next"/);
                if (nextMatch) nextPageUrl = nextMatch[1];
            }
            if (nextPageUrl) await new Promise(r => setTimeout(r, 500));
        }
        res.json({ skus, count: skus.length });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// ==================== ì¹´í…Œê³ ë¦¬ ëª©ë¡ API (ì—‘ì…€ ë‹¤ìš´ë¡œë“œìš©) ====================
app.get('/api/export-categories', (req, res) => {
    const categories = (urlQueue.categories || []).map(c => ({
        id: c.id,
        name: c.name,
        maxProducts: c.maxProducts,
        maxPages: c.maxPages,
        status: c.status
    }));
    res.json(categories);
});

// ==================== NocoDB ì—‘ì…€ ë‹¤ìš´ë¡œë“œ API (ì¹´í…Œê³ ë¦¬ë³„ + 2ì‹œíŠ¸) ====================
// ì´ë¯¸ì§€ attachmentì—ì„œ URLë§Œ ì¶”ì¶œí•˜ëŠ” í—¬í¼
function extractAttachmentUrls(field) {
    if (!field) return '';
    const arr = Array.isArray(field) ? field : [field];
    return arr.map(img => {
        if (!img) return '';
        return img.url || (img.path ? `${NOCODB_API_URL}/${img.path}` : '');
    }).filter(u => u).join(' | ');
}

// ì‹œë“œë‹ˆ ì‹œê°„ í¬ë§· (íŒŒì¼ëª…ìš©)
function getSydneyTimeForFilename() {
    const now = new Date();
    const sydneyDate = new Date(now.toLocaleString('en-US', { timeZone: 'Australia/Sydney' }));
    const y = sydneyDate.getFullYear();
    const mo = String(sydneyDate.getMonth() + 1).padStart(2, '0');
    const d = String(sydneyDate.getDate()).padStart(2, '0');
    const h = String(sydneyDate.getHours()).padStart(2, '0');
    const mi = String(sydneyDate.getMinutes()).padStart(2, '0');
    const s = String(sydneyDate.getSeconds()).padStart(2, '0');
    return `${y}-${mo}-${d}_${h}-${mi}-${s}`;
}

// NocoDB í…Œì´ë¸” ì „ì²´ ë ˆì½”ë“œ ê°€ì ¸ì˜¤ê¸° (íŽ˜ì´ì§€ë„¤ì´ì…˜)
async function fetchAllRecords(tableId) {
    const allRecords = [];
    let offset = 0;
    const pageSize = 200;
    while (true) {
        const response = await axios.get(
            `${NOCODB_API_URL}/api/v2/tables/${tableId}/records`,
            {
                headers: { 'xc-token': NOCODB_API_TOKEN },
                params: { limit: pageSize, offset: offset }
            }
        );
        const records = response.data.list || [];
        allRecords.push(...records);
        if (records.length < pageSize) break;
        offset += pageSize;
    }
    return allRecords;
}

// í—¤ë” ìŠ¤íƒ€ì¼ ì ìš© í—¬í¼
function applyHeaderStyle(worksheet, argbColor) {
    worksheet.getRow(1).font = { bold: true, color: { argb: 'FFFFFFFF' } };
    worksheet.getRow(1).fill = {
        type: 'pattern',
        pattern: 'solid',
        fgColor: { argb: argbColor }
    };
}

app.get('/api/export-excel', async (req, res) => {
    try {
        const { categoryId } = req.query;

        // ì¹´í…Œê³ ë¦¬ ì •ë³´ í™•ì¸
        let categoryName = 'All';
        let maxProducts = 0;
        let maxPages = 0;

        if (categoryId && categoryId !== 'all') {
            const cat = (urlQueue.categories || []).find(c => c.id === categoryId);
            if (cat) {
                categoryName = cat.name || 'Unnamed';
                maxProducts = cat.maxProducts || 0;
                maxPages = cat.maxPages || 0;
            }
        }

        addLog('info', `ðŸ“¥ ì—‘ì…€ ë‹¤ìš´ë¡œë“œ ìš”ì²­: ${categoryName}`);

        // ì–‘ìª½ í…Œì´ë¸” ë°ì´í„° ë¡œë“œ
        const [oliveyoungRecords, shopifyRecords] = await Promise.all([
            fetchAllRecords(OLIVEYOUNG_TABLE_ID),
            fetchAllRecords(SHOPIFY_TABLE_ID)
        ]);

        addLog('info', `ðŸ“Š Oliveyoung: ${oliveyoungRecords.length}ê°œ, Shopify: ${shopifyRecords.length}ê°œ ë¡œë“œ`);

        // ExcelJS ì›Œí¬ë¶ ìƒì„±
        const workbook = new ExcelJS.Workbook();
        workbook.creator = 'Copychu Dashboard';
        workbook.created = new Date();

        // ==================== Sheet 1: Shopify Products ====================
        const wsShopify = workbook.addWorksheet('Shopify Products');
        wsShopify.columns = [
            { header: 'Id', key: 'Id', width: 8 },
            { header: 'OliveYoung Product ID', key: 'oliveyoung_product_id', width: 12 },
            { header: 'Title (EN)', key: 'title_en', width: 40 },
            { header: 'Price (AUD)', key: 'price_aud', width: 12 },
            { header: 'Description (EN)', key: 'description_en', width: 50 },
            { header: 'Main Image URL', key: 'main_image', width: 60 },
            { header: 'Gallery Images URL', key: 'gallery_images', width: 80 },
            { header: 'Shopify Product ID', key: 'shopify_product_id', width: 20 },
            { header: 'Shopify Status', key: 'shopify_status', width: 14 },
            { header: 'Uploaded At', key: 'uploaded_at', width: 22 },
            { header: 'Made At', key: 'made_at', width: 22 },
            { header: 'AI Product Images', key: 'ai_product_images', width: 60 },
            { header: 'Validated Images', key: 'validated_images', width: 60 }
        ];
        applyHeaderStyle(wsShopify, 'FF22D3EE');

        for (const r of shopifyRecords) {
            wsShopify.addRow({
                Id: r.Id,
                oliveyoung_product_id: r.oliveyoung_product_id || '',
                title_en: r.title_en || '',
                price_aud: r.price_aud || '',
                description_en: r.description_en || '',
                main_image: extractAttachmentUrls(r.main_image),
                gallery_images: extractAttachmentUrls(r.gallery_images),
                shopify_product_id: r.shopify_product_id || '',
                shopify_status: r.shopify_status || '',
                uploaded_at: r.uploaded_at || '',
                made_at: r.made_at || '',
                ai_product_images: extractAttachmentUrls(r.ai_product_images),
                validated_images: extractAttachmentUrls(r.validated_images)
            });
        }

        // ==================== Sheet 2: Oliveyoung Products ====================
        const wsOliveyoung = workbook.addWorksheet('Oliveyoung Products');
        wsOliveyoung.columns = [
            { header: 'Id', key: 'Id', width: 8 },
            { header: 'SKU', key: 'sku', width: 18 },
            { header: 'Title (KR)', key: 'title_kr', width: 40 },
            { header: 'Title (EN)', key: 'title_en', width: 40 },
            { header: 'Price (Original)', key: 'price_original', width: 14 },
            { header: 'Price (Discount)', key: 'price_discount', width: 14 },
            { header: 'Category', key: 'category', width: 20 },
            { header: 'Product URL', key: 'product_url', width: 60 },
            { header: 'Description', key: 'description', width: 50 },
            { header: 'Description (EN)', key: 'description_en', width: 50 },
            { header: 'Image URLs', key: 'image_urls', width: 60 },
            { header: 'Product Images', key: 'product_images', width: 60 },
            { header: 'Screenshot', key: 'screenshot', width: 60 },
            { header: 'Scraped At', key: 'scraped_at', width: 22 }
        ];
        applyHeaderStyle(wsOliveyoung, 'FF16A34A');

        for (const r of oliveyoungRecords) {
            wsOliveyoung.addRow({
                Id: r.Id,
                sku: r.sku || '',
                title_kr: r.title_kr || '',
                title_en: r.title_en || '',
                price_original: r.price_original || '',
                price_discount: r.price_discount || '',
                category: r.category || '',
                product_url: r.product_url || '',
                description: r.description || '',
                description_en: r.description_en || '',
                image_urls: typeof r.image_urls === 'string' ? r.image_urls : extractAttachmentUrls(r.image_urls),
                product_images: extractAttachmentUrls(r.product_images),
                screenshot: extractAttachmentUrls(r.screenshot),
                scraped_at: r.scraped_at || ''
            });
        }

        // íŒŒì¼ëª… ìƒì„±: {CategoryName}_{MaxProducts}p_{LimitPages}pg_{Sydneyì‹œê°„}.xlsx
        const sydneyTime = getSydneyTimeForFilename();
        // ì¹´í…Œê³ ë¦¬ëª…ì—ì„œ íŒŒì¼ëª…ì— ì•ˆì „í•˜ì§€ ì•Šì€ ë¬¸ìž ì œê±°
        const safeCatName = categoryName.replace(/[\/\\:*?"<>|]/g, '_').replace(/\s+/g, '_');
        const pagesLabel = maxPages === 0 ? 'unlimited' : `${maxPages}pg`;
        const filename = categoryId && categoryId !== 'all'
            ? `${safeCatName}_${maxProducts}p_${pagesLabel}_${sydneyTime}.xlsx`
            : `All_Products_${sydneyTime}.xlsx`;

        // ì‘ë‹µ í—¤ë” ì„¤ì •
        res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
        res.setHeader('Content-Disposition', `attachment; filename="${encodeURIComponent(filename)}"`);

        // ì—‘ì…€ íŒŒì¼ì„ ìŠ¤íŠ¸ë¦¼ìœ¼ë¡œ ì „ì†¡
        await workbook.xlsx.write(res);
        res.end();

        addLog('success', `âœ… ì—‘ì…€ ë‹¤ìš´ë¡œë“œ ì™„ë£Œ: ${filename} (Shopify: ${shopifyRecords.length}, OliveYoung: ${oliveyoungRecords.length})`);

    } catch (error) {
        console.error('âŒ ì—‘ì…€ ë‹¤ìš´ë¡œë“œ ì‹¤íŒ¨:', error.message);
        addLog('error', `âŒ ì—‘ì…€ ë‹¤ìš´ë¡œë“œ ì‹¤íŒ¨: ${error.message}`);
        if (!res.headersSent) {
            res.status(500).json({ error: 'ì—‘ì…€ ë‹¤ìš´ë¡œë“œ ì‹¤íŒ¨: ' + error.message });
        }
    }
});

// ==================== íŒë§¤ ì¤‘ë‹¨ ì œí’ˆ ì²´í¬ API ====================
let discontinuedCheckRunning = false;

app.post('/api/check-discontinued', async (req, res) => {
    if (systemState.status === 'running') {
        return res.status(400).json({ error: 'íŒŒì´í”„ë¼ì¸ ì‹¤í–‰ ì¤‘ì—ëŠ” ì²´í¬í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.' });
    }
    if (discontinuedCheckRunning) {
        return res.status(400).json({ error: 'ì´ë¯¸ ì²´í¬ê°€ ì§„í–‰ ì¤‘ìž…ë‹ˆë‹¤.' });
    }

    discontinuedCheckRunning = true;
    res.json({ success: true, message: 'íŒë§¤ ì¤‘ë‹¨ ì²´í¬ë¥¼ ì‹œìž‘í•©ë‹ˆë‹¤.' });

    try {
        // 1. Shopifyì—ì„œ active ì œí’ˆ ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
        addLog('info', 'ðŸ” Shopifyì—ì„œ active ì œí’ˆ ëª©ë¡ ê°€ì ¸ì˜¤ëŠ” ì¤‘...');
        io.emit('discontinuedProgress', { status: 'fetching', message: 'Shopify ì œí’ˆ ëª©ë¡ ê°€ì ¸ì˜¤ëŠ” ì¤‘...' });

        const products = [];
        let nextPageUrl = `https://${SHOPIFY_STORE_URL}/admin/api/${SHOPIFY_API_VERSION}/products.json?limit=250&status=active&fields=id,title,variants`;
        while (nextPageUrl) {
            const response = await axios.get(nextPageUrl, {
                headers: { 'X-Shopify-Access-Token': SHOPIFY_ACCESS_TOKEN },
                timeout: 30000
            });
            for (const product of (response.data.products || [])) {
                const sku = product.variants?.[0]?.sku;
                if (sku) {
                    products.push({ id: product.id, title: product.title, sku });
                }
            }
            nextPageUrl = null;
            const linkHeader = response.headers['link'];
            if (linkHeader) {
                const nextMatch = linkHeader.match(/<([^>]+)>;\s*rel="next"/);
                if (nextMatch) nextPageUrl = nextMatch[1];
            }
            if (nextPageUrl) await new Promise(r => setTimeout(r, 500));
        }

        addLog('info', `ðŸ“¦ ì´ ${products.length}ê°œ active ì œí’ˆ ë°œê²¬`);
        io.emit('discontinuedProgress', { status: 'checking', message: `${products.length}ê°œ ì œí’ˆ ì²´í¬ ì‹œìž‘`, total: products.length, current: 0 });

        // 2. ê° SKUë¡œ ì˜¬ë¦¬ë¸Œì˜ íŽ˜ì´ì§€ ì²´í¬
        const results = { total: products.length, active: 0, discontinued: [], failed: [] };

        for (let i = 0; i < products.length; i++) {
            const product = products[i];
            const url = `https://www.oliveyoung.co.kr/store/goods/getGoodsDetail.do?goodsNo=${product.sku}`;

            io.emit('discontinuedProgress', {
                status: 'checking',
                message: `[${i + 1}/${products.length}] ${product.title}`,
                total: products.length,
                current: i + 1
            });

            try {
                const response = await axios.get(url, {
                    timeout: 15000,
                    headers: {
                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
                        'Accept-Language': 'ko-KR,ko;q=0.9'
                    },
                    maxRedirects: 5,
                    validateStatus: (status) => status < 500
                });

                const html = typeof response.data === 'string' ? response.data : '';
                const finalUrl = response.request?.res?.responseUrl || response.config?.url || url;
                const isRedirectedToMain = finalUrl.includes('/main') || finalUrl.includes('/store/main');
                const isDiscontinued = response.status === 404 ||
                    isRedirectedToMain ||
                    html.includes('íŒë§¤ì¤‘ë‹¨') ||
                    html.includes('ì¡´ìž¬í•˜ì§€ ì•ŠëŠ” ìƒí’ˆ') ||
                    (html.includes('ì¼ì‹œí’ˆì ˆ') && !html.includes('ìž¥ë°”êµ¬ë‹ˆ'));

                if (isDiscontinued) {
                    // Shopifyì—ì„œ draft ì²˜ë¦¬
                    try {
                        await axios.put(
                            `https://${SHOPIFY_STORE_URL}/admin/api/${SHOPIFY_API_VERSION}/products/${product.id}.json`,
                            { product: { id: product.id, status: 'draft' } },
                            { headers: { 'X-Shopify-Access-Token': SHOPIFY_ACCESS_TOKEN, 'Content-Type': 'application/json' }, timeout: 15000 }
                        );
                        results.discontinued.push({ sku: product.sku, title: product.title, reason: isRedirectedToMain ? 'redirect' : 'page_content' });
                        addLog('warning', `â›” íŒë§¤ì¤‘ë‹¨ â†’ Draft: [${product.sku}] ${product.title}`);
                    } catch (putErr) {
                        results.failed.push({ sku: product.sku, title: product.title, error: 'Draft ë³€ê²½ ì‹¤íŒ¨: ' + putErr.message });
                        addLog('error', `âŒ Draft ë³€ê²½ ì‹¤íŒ¨: [${product.sku}] ${putErr.message}`);
                    }
                } else {
                    results.active++;
                }
            } catch (error) {
                if (error.response?.status === 404 || error.code === 'ECONNREFUSED') {
                    results.discontinued.push({ sku: product.sku, title: product.title, reason: 'not_found' });
                    addLog('warning', `â›” ì ‘ê·¼ë¶ˆê°€ â†’ Draft: [${product.sku}] ${product.title}`);
                    try {
                        await axios.put(
                            `https://${SHOPIFY_STORE_URL}/admin/api/${SHOPIFY_API_VERSION}/products/${product.id}.json`,
                            { product: { id: product.id, status: 'draft' } },
                            { headers: { 'X-Shopify-Access-Token': SHOPIFY_ACCESS_TOKEN, 'Content-Type': 'application/json' }, timeout: 15000 }
                        );
                    } catch (e) { /* ignore */ }
                } else {
                    results.failed.push({ sku: product.sku, title: product.title, error: error.message });
                }
            }

            // Rate limit: ì˜¬ë¦¬ë¸Œì˜ ìš”ì²­ ê°„ 2ì´ˆ ëŒ€ê¸°
            if (i < products.length - 1) {
                await new Promise(r => setTimeout(r, 2000));
            }
        }

        // 3. ê²°ê³¼ ì „ì†¡
        addLog('success', `âœ… íŒë§¤ ì¤‘ë‹¨ ì²´í¬ ì™„ë£Œ: ì´ ${results.total}ê°œ, ì •ìƒ ${results.active}ê°œ, ì¤‘ë‹¨ ${results.discontinued.length}ê°œ, ì‹¤íŒ¨ ${results.failed.length}ê°œ`);
        io.emit('discontinuedResult', results);

    } catch (error) {
        addLog('error', `âŒ íŒë§¤ ì¤‘ë‹¨ ì²´í¬ ì‹¤íŒ¨: ${error.message}`);
        io.emit('discontinuedResult', { error: error.message });
    } finally {
        discontinuedCheckRunning = false;
    }
});

// ==================== Socket.io ====================
io.on('connection', (socket) => {
    console.log('ðŸ”Œ í´ë¼ì´ì–¸íŠ¸ ì—°ê²°ë¨:', socket.id);
    
    socket.emit('state', systemState);
    socket.emit('logs', logs.slice(-100));
    socket.emit('urlQueue', urlQueue);
    
    socket.on('disconnect', () => {
        console.log('ðŸ”Œ í´ë¼ì´ì–¸íŠ¸ ì—°ê²° í•´ì œ:', socket.id);
    });
});

// ==================== ì„œë²„ ì‹œìž‘ ====================
httpServer.listen(PORT, '0.0.0.0', () => {
    console.log('='.repeat(60));
    console.log('ðŸš€ Copychu Dashboard ì„œë²„ ì‹œìž‘!');
    console.log('='.repeat(60));
    console.log(`ðŸ“¡ ì£¼ì†Œ: http://localhost:${PORT}`);
    console.log(`ðŸ“¡ ì™¸ë¶€ ì ‘ì†: http://77.42.67.165:${PORT}`);
    console.log(`ðŸ“‚ ìŠ¤í¬ë¦½íŠ¸ ê²½ë¡œ: ${SCRIPTS_DIR}`);
    console.log('='.repeat(60));
    console.log('\nðŸ“‹ ì‚¬ìš© ê°€ëŠ¥í•œ Phase:');
    PHASES.forEach(p => console.log(`   - ${p.name}`));
    console.log('\nðŸ”— URL í API:');
    console.log('   - GET  /api/url-queue');
    console.log('   - POST /api/url-queue/category');
    console.log('   - POST /api/url-queue/process');
    console.log('   - POST /api/url-queue/process-full');
    console.log('   - POST /api/force-kill  â† ðŸ†• ê°•ì œ ì¢…ë£Œ');
    console.log('='.repeat(60));
});
// ==================== Graceful Shutdown ====================
function gracefulShutdown(signal) {
    console.log(`\nâš ï¸ ${signal} ìˆ˜ì‹  - ì„œë²„ ì¢…ë£Œ ì¤‘...`);
    
    // 1. ì‹¤í–‰ ì¤‘ì¸ í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œ
    if (currentProcess) {
        try {
            currentProcess.kill('SIGTERM');
            currentProcess = null;
            console.log('âœ… í˜„ìž¬ í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œë¨');
        } catch (e) {
            console.log('âš ï¸ í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œ ì‹¤íŒ¨:', e.message);
        }
    }
    
    // 2. ëª¨ë“  ì†Œì¼“ ì—°ê²° ì¢…ë£Œ
    io.close(() => {
        console.log('âœ… Socket.io ì—°ê²° ì¢…ë£Œë¨');
    });
    
    // 3. HTTP ì„œë²„ ì¢…ë£Œ
    httpServer.close(() => {
        console.log('âœ… HTTP ì„œë²„ ì¢…ë£Œë¨');
        console.log('ðŸ‘‹ ì„œë²„ ì™„ì „ížˆ ì¢…ë£Œë¨');
        process.exit(0);
    });
    
    // 4. 5ì´ˆ í›„ ê°•ì œ ì¢…ë£Œ (ì•ˆì „ìž¥ì¹˜)
    setTimeout(() => {
        console.log('âš ï¸ ê°•ì œ ì¢…ë£Œ (íƒ€ìž„ì•„ì›ƒ)');
        process.exit(1);
    }, 5000);
}

process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));
process.on('SIGINT', () => gracefulShutdown('SIGINT'));
process.on('uncaughtException', (err) => {
    console.error('âŒ Uncaught Exception:', err);
    gracefulShutdown('uncaughtException');
});